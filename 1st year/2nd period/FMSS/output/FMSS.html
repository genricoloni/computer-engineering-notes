<!doctype html>
<html  lang="it" >
<head>
    <style>
		#TOC {
			overflow-y: hidden !important; 
			font-size: smaller !important;
			/*margin-right: 20px;*/
		}

		p, h1, h2, h3, h4, h5, a, span, li, ul, ol, th, tr, table, figcaption {
			font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Open Sans","Helvetica Neue",sans-serif !important;
		}

		[class*="span"] {
			margin-left: 0 !important;
		}

		.well {
			min-height: 0px !important;
			padding: 0px !important;
			margin-bottom: 0px !important;
			background-color: #FFFFFF  !important;
			border: 0 !important;
			-webkit-border-radius: 0 !important;
			-moz-border-radius: 0 !important;
			border-radius: 0 !important;
			-webkit-box-shadow: none !important;
			-moz-box-shadow: none !important;
			box-shadow: none !important;
		}

		.navbar-inner {
			background-color: #fefefe !important;
			background-image: none !important;
			background-repeat: no-repeat !important;
			filter: none !important;
			border: 0 !important;
			-webkit-border-radius: 0px !important;
			-moz-border-radius: 0px !important;
			border-radius: 0px !important;
			margin-bottom: 15pt !important;

			-webkit-box-shadow: 0 1px 10px rgb(0 0 0 / 7%) !important;
			-moz-box-shadow: 0 1px 10px rgba(0,0,0,.07) 1 !important;
			box-shadow: 0 1px 10px rgb(0 0 0 / 7%) !important;
		}
		
		
		li > ul {
			padding-left: 15px !important;
		}

		pre {
			background-color: #f6f8fa !important;
			border-radius: 3px !important;
			/*font-size: 85% !important;*/
			line-height: 1.45 !important;
			overflow: auto !important;
			padding: 16px !important;
			font-family: Monaco, Menlo, Consolas, "Courier New", monospace !important;
			border: 0 !important;
		}
		
		code {
			/*background-color: rgba(27,31,35,.05) !important;*/
			border-radius: 3px !important;
			border: 0 !important;
			/*font-size: 85% !important;*/
			margin: 0 !important;
			padding: 0.2em 0.4em !important;
			font-family: Monaco, Menlo, Consolas, "Courier New", monospace !important;
		}

		table th {
			background-color: #f6f8fa !important;
		}

		
		.math * {
			font-family: Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman', serif !important;
		}

		.katex-display>.katex>.katex-html {
			font-size: 85% !important;
			font-family: Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman', serif !important;
		}

		/*distanzia*/
		h1:not(:first-of-type){
			margin-top: 50px !important;
		}

		/* fa comparire la barra del capitolo */
		h1 {
			border-bottom: 1px solid #e8e8e8fa !important;
			font-size: 2.2em !important;
		}

		/*distanzia*/
		h2 {
			margin-top: 30px !important;
			font-size: 1.6em !important;
		}

		/*distanzia*/
		h3 {
			margin-top: 20px !important;
			font-size: 1.3em !important;
		}

		h4 {
			font-size: 1em !important;
		}

		/* stile box */
		.note, .tip, .caution, .warning, .attention, .error, .danger, .definition {
			border-radius: 5pt;
			padding-left: 10px;
			padding-right: 10px;
			padding-top: 1px;
			padding-bottom: 1px;
			line-height: normal;
			color: #000000ab;
			margin: 6pt 0pt 6pt 0pt;
		}

		.note code, .tip code, .caution code, .warning code, .attention code, .error code, .danger code, .definition code, .danger code {
			background-color: #00000014;
		}

		.note {
			background-color: #88d3f9;
		}

		.tip {
			background-color: #87f0b8;
		}

		.caution, .warning, .attention {
			background-color: #ffe162;
		}

		.error, .danger {
			background-color: #ff7474;
		}

		.definition {
			background-color: #f191ff;
		}

		.table {
			border-top: 1px solid #ddd;
			margin-top: 15px;
		}


	</style>

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />

    <!-- <link rel="stylesheet" type="text/css" href="template.css" /> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/template.css" />

    <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />

    <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
    <!-- <script type='text/javascript' src='menu/js/jquery.cookie.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script> -->

    <!-- <link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" /> -->
  
    <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
        
  
    <!-- <script src="script.js"></script> -->
  
    <!-- <script src="jquery.sticky-kit.js "></script> -->
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.cookie.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.hoverIntent.minified.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/ryangrose/easy-pandoc-templates@948e28e5/css/elegant_bootstrap.css" rel="stylesheet" type="text/css" />
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/script.js"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/jquery.sticky-kit.js"></script>
    <meta name="generator" content="pandoc" />
  <meta name="author" content="Giovanni Enrico Loni" />
  <title>Formal Methods for Secure Systems</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  
</head>
<body>

    
    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">Formal Methods for Secure Systems</span>
        <ul class="nav pull-right doc-info">
                    <li><p class="navbar-text">Giovanni Enrico
Loni</p></li>
                            </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

        <ul>
        <li><a href="#introduction"
        id="toc-introduction">Introduction</a>
        <ul>
        <li><a href="#outline-of-the-course"
        id="toc-outline-of-the-course">Outline of the course</a></li>
        <li><a href="#computer-based-systems"
        id="toc-computer-based-systems">Computer-based systems</a></li>
        </ul></li>
        <li><a href="#basic-concepts-and-terminology"
        id="toc-basic-concepts-and-terminology">Basic concepts and
        terminology</a>
        <ul>
        <li><a href="#dependability"
        id="toc-dependability">Dependability</a>
        <ul>
        <li><a href="#computer-based-systems-1"
        id="toc-computer-based-systems-1">Computer-based
        systems</a></li>
        <li><a href="#faults-and-failures"
        id="toc-faults-and-failures">Faults and Failures</a></li>
        <li><a href="#achieving-dependability"
        id="toc-achieving-dependability">Achieving
        Dependability</a></li>
        </ul></li>
        <li><a href="#the-system-entity" id="toc-the-system-entity">The
        <em>system</em> entity</a>
        <ul>
        <li><a href="#systems-properties"
        id="toc-systems-properties">System’s properties</a></li>
        <li><a href="#systems-requirements"
        id="toc-systems-requirements">System’s requirements</a></li>
        </ul></li>
        <li><a href="#dependability-tree"
        id="toc-dependability-tree">Dependability tree</a>
        <ul>
        <li><a href="#threats-to-dependability"
        id="toc-threats-to-dependability">Threats to
        dependability</a></li>
        <li><a href="#dependability-attributes"
        id="toc-dependability-attributes">Dependability
        attributes</a></li>
        </ul></li>
        <li><a href="#taxonomy-of-faults"
        id="toc-taxonomy-of-faults">Taxonomy of faults</a>
        <ul>
        <li><a href="#the-system-life-cycle"
        id="toc-the-system-life-cycle">The system life cycle</a></li>
        <li><a href="#faults-classification"
        id="toc-faults-classification">Faults classification</a></li>
        </ul></li>
        <li><a href="#failures" id="toc-failures">Failures</a>
        <ul>
        <li><a href="#failure-domain" id="toc-failure-domain">Failure
        domain</a></li>
        <li><a href="#consistency-domain"
        id="toc-consistency-domain">Consistency domain</a></li>
        <li><a href="#detectability-domain"
        id="toc-detectability-domain">Detectability domain</a></li>
        <li><a href="#consequences-domain"
        id="toc-consequences-domain">Consequences domain</a></li>
        <li><a href="#criteria-to-evaluate-the-severity-of-a-failure"
        id="toc-criteria-to-evaluate-the-severity-of-a-failure">Criteria
        to evaluate the severity of a failure</a></li>
        <li><a href="#system-failures" id="toc-system-failures">System
        failures</a></li>
        <li><a href="#dependability-and-security-failures"
        id="toc-dependability-and-security-failures">Dependability and
        security failures</a></li>
        </ul></li>
        <li><a href="#errors" id="toc-errors">Errors</a></li>
        <li><a
        href="#chain-of-threats---relationship-between-faults-errors-and-failures"
        id="toc-chain-of-threats---relationship-between-faults-errors-and-failures">Chain
        of threats - Relationship between faults, errors and
        failures</a></li>
        <li><a href="#dependability-means"
        id="toc-dependability-means">Dependability means</a>
        <ul>
        <li><a href="#fault-prevention" id="toc-fault-prevention">Fault
        prevention</a></li>
        <li><a href="#fault-tolerance" id="toc-fault-tolerance">Fault
        tolerance</a></li>
        <li><a href="#fault-handling" id="toc-fault-handling">Fault
        handling</a></li>
        <li><a href="#fault-removal" id="toc-fault-removal">Fault
        removal</a></li>
        <li><a href="#fault-forecasting"
        id="toc-fault-forecasting">Fault forecasting</a></li>
        <li><a href="#error-recovery" id="toc-error-recovery">Error
        recovery</a></li>
        </ul></li>
        <li><a href="#error-detection" id="toc-error-detection">Error
        detection</a>
        <ul>
        <li><a href="#structural-approach-to-error-detection"
        id="toc-structural-approach-to-error-detection">Structural
        approach to error detection</a></li>
        <li><a href="#measurement-of-effectiveness-of-error-detection"
        id="toc-measurement-of-effectiveness-of-error-detection">Measurement
        of effectiveness of error detection</a></li>
        <li><a href="#the-exception-handling"
        id="toc-the-exception-handling">The exception handling</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#redundancy-in-fault-tolerant-computing"
        id="toc-redundancy-in-fault-tolerant-computing">Redundancy in
        Fault Tolerant Computing</a>
        <ul>
        <li><a href="#hardware-redundancy"
        id="toc-hardware-redundancy">Hardware Redundancy</a>
        <ul>
        <li><a href="#passive-fault-tolerance-techniques"
        id="toc-passive-fault-tolerance-techniques">Passive fault
        tolerance techniques</a></li>
        <li><a href="#active-fault-tolerance-techniques"
        id="toc-active-fault-tolerance-techniques">Active fault
        tolerance techniques</a></li>
        <li><a href="#hybrid-fault-tolerance-techniques"
        id="toc-hybrid-fault-tolerance-techniques">Hybrid fault
        tolerance techniques</a></li>
        <li><a href="#summary-of-the-hardware-redundancy-techniques"
        id="toc-summary-of-the-hardware-redundancy-techniques">Summary
        of the hardware redundancy techniques</a></li>
        </ul></li>
        <li><a href="#information-redundancy"
        id="toc-information-redundancy">Information Redundancy</a>
        <ul>
        <li><a href="#parity-codes" id="toc-parity-codes">Parity
        codes</a></li>
        <li><a href="#complemented-duplication"
        id="toc-complemented-duplication">Complemented
        duplication</a></li>
        <li><a href="#hamming-distance"
        id="toc-hamming-distance">Hamming distance</a></li>
        <li><a href="#checksums" id="toc-checksums">Checksums</a></li>
        <li><a href="#ecc" id="toc-ecc">ECC</a></li>
        <li><a href="#hamming-codes" id="toc-hamming-codes">Hamming
        codes</a></li>
        <li><a href="#self-checking-circuitry"
        id="toc-self-checking-circuitry">Self-checking
        circuitry</a></li>
        </ul></li>
        <li><a href="#time-redundancy" id="toc-time-redundancy">Time
        Redundancy</a>
        <ul>
        <li><a href="#repetition-of-the-computation"
        id="toc-repetition-of-the-computation">Repetition of the
        computation</a></li>
        </ul></li>
        <li><a href="#software-redundancy"
        id="toc-software-redundancy">Software Redundancy</a>
        <ul>
        <li><a href="#software-diversity"
        id="toc-software-diversity">Software diversity</a></li>
        <li><a href="#n-version-programming"
        id="toc-n-version-programming">N-version programming</a></li>
        <li><a href="#design-diversity" id="toc-design-diversity">Design
        diversity</a></li>
        </ul></li>
        </ul></li>
        <li><a
        href="#basic-building-blocks-in-fault-tolerant-distributed-systems"
        id="toc-basic-building-blocks-in-fault-tolerant-distributed-systems">Basic
        building blocks in Fault tolerant distributed systems</a>
        <ul>
        <li><a href="#atomic-actions" id="toc-atomic-actions">Atomic
        actions</a>
        <ul>
        <li><a href="#atomic-actions-in-a-database"
        id="toc-atomic-actions-in-a-database">Atomic actions in a
        database</a></li>
        <li><a href="#atomic-actions-in-a-distributed-system"
        id="toc-atomic-actions-in-a-distributed-system">Atomic actions
        in a distributed system</a></li>
        <li><a href="#two-phase-commit"
        id="toc-two-phase-commit">Two-phase commit</a></li>
        <li><a href="#three-phase-commit"
        id="toc-three-phase-commit">Three-phase commit</a></li>
        <li><a href="#recovery-and-atomicity"
        id="toc-recovery-and-atomicity">Recovery and atomicity</a></li>
        <li><a href="#log-file" id="toc-log-file">Log file</a></li>
        </ul></li>
        <li><a href="#consensus-problem"
        id="toc-consensus-problem">Consensus problem</a>
        <ul>
        <li><a href="#the-byzantine-generals-problem"
        id="toc-the-byzantine-generals-problem">The Byzantine Generals
        problem</a></li>
        <li><a href="#oral-message-algorithm"
        id="toc-oral-message-algorithm">Oral message algorithm</a></li>
        <li><a href="#consideration-about-the-algorithm"
        id="toc-consideration-about-the-algorithm">Consideration about
        the algorithm</a></li>
        <li><a href="#signed-messages" id="toc-signed-messages">Signed
        messages</a></li>
        <li><a href="#impossibility-results"
        id="toc-impossibility-results">Impossibility results</a></li>
        <li><a href="#clock-synchronization"
        id="toc-clock-synchronization">CLock synchronization</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#dependability-evaluation"
        id="toc-dependability-evaluation">Dependability Evaluation</a>
        <ul>
        <li><a href="#introduction-1"
        id="toc-introduction-1">Introduction</a>
        <ul>
        <li><a href="#definitions"
        id="toc-definitions">Definitions</a></li>
        <li><a href="#hardware-reliability"
        id="toc-hardware-reliability">Hardware reliability</a></li>
        <li><a href="#time-to-failure-of-a-component"
        id="toc-time-to-failure-of-a-component">Time-to-failure of a
        component</a></li>
        <li><a href="#distribution-model-for-permanent-faults"
        id="toc-distribution-model-for-permanent-faults">Distribution
        model for permanent faults</a></li>
        </ul></li>
        <li><a href="#model-based-dependability-evaluation"
        id="toc-model-based-dependability-evaluation">Model-based
        dependability evaluation</a></li>
        <li><a href="#combinatorial-stochastic-models"
        id="toc-combinatorial-stochastic-models">Combinatorial
        (stochastic) models</a>
        <ul>
        <li><a href="#series-models" id="toc-series-models">Series
        models</a></li>
        <li><a href="#parallel-models" id="toc-parallel-models">Parallel
        models</a></li>
        <li><a href="#example-tmr-vs-simplex-system"
        id="toc-example-tmr-vs-simplex-system">Example: TMR vs Simplex
        system</a></li>
        <li><a href="#non-seriesparallel-systems"
        id="toc-non-seriesparallel-systems">Non-series/parallel
        systems</a></li>
        <li><a href="#fault-trees" id="toc-fault-trees">Fault
        Trees</a></li>
        <li><a href="#failure-mode-and-effect-analysis"
        id="toc-failure-mode-and-effect-analysis">Failure Mode and
        Effect Analysis</a></li>
        <li><a href="#fmea-with-fault-trees"
        id="toc-fmea-with-fault-trees">FMEA with Fault Trees</a></li>
        </ul></li>
        <li><a href="#state-based-models"
        id="toc-state-based-models">State-based models</a>
        <ul>
        <li><a href="#representing-the-system-state"
        id="toc-representing-the-system-state">Representing the system
        state</a></li>
        <li><a href="#random-process" id="toc-random-process">Random
        process</a></li>
        <li><a href="#markov-chains" id="toc-markov-chains">Markov
        Chains</a></li>
        </ul></li>
        </ul></li>
        </ul>

        </div>
      </div>
            <div class="span9">

      
      <h1 id="introduction">Introduction</h1>
<h2 id="outline-of-the-course">Outline of the course</h2>
<ol type="1">
<li>Dependability
<ul>
<li>Building high reliable computer-based systems</li>
<li>Quantitative evaluation of dependability</li>
<li>Threat modeling and risk assessment</li>
<li>Malware analysis</li>
<li>Cybersecurity engineering</li>
</ul></li>
<li>Formal methods for security
<ul>
<li>Formal methods applied to security</li>
<li>Case studies: Data confidentiality, Security protocols,
Cyber-physical systems security</li>
</ul></li>
</ol>
<h2 id="computer-based-systems">Computer-based systems</h2>
<p>Computer-based systems are everywhere, and the services they offer
are very diverses. From that, we can easy understand why the
<strong>dependability</strong>, which is the ability of the system to
deliver the expected service, is a critical aspect of these systems, in
particular in a security point of view.</p>
<p>A system should (or must) be able to deliver the expected service,
even in the presence of faults, errors, and <strong>attacks</strong>.
This is the main goal of dependability, which is as important as the
functionality of the system, pheraps even more. TO achieve that, we have
<strong>Formal Methods</strong> that provide to us a set of techniques
and tools to design, verify, and validate computer-based systems, in a
rigorous and systematic way, even in presence of faults and attacks.</p>
<h1 id="basic-concepts-and-terminology">Basic concepts and
terminology</h1>
<p>All the concept and the terminology that will be presented in this
section derives directly from the paper “Basic Concepts and Taxonomy of
Dependable and Secure Computing” by Avizienis et al. (2004). This paper
is a fundamental reference in the field of dependability and security
and it is the basis for the definition of the concepts and terminology
that will be used in the entire course, as suggested by the
professor.</p>
<h2 id="dependability">Dependability</h2>
<p>We can give to <strong>dependability</strong> a simple definition:
given a system, which is designed to provide a certain service, the
dependability is the ability of that system to deliver the specified
service also in presence of faults and malfunctions. In other words
<em>dependability is that property of a computer-based system such that
reliance can justifiably be placed on the service it delivers</em>. Note
that the latter definition stresses the need for a justified reliance on
the service, which is a key aspect of dependability.</p>
<h3 id="computer-based-systems-1">Computer-based systems</h3>
<p>A computer-based system is a system that includes a certain number of
components: each of them can be interconnected and have its own
functionality. The components can be hardware, software, humans and the
environment in which the system operates.</p>
<figure>
<img src="../images/01/computer%20sysmet.png" width="500"
alt="Computer-based system - C. Bernardeschi" />
<figcaption aria-hidden="true">Computer-based system - C.
Bernardeschi</figcaption>
</figure>
<h3 id="faults-and-failures">Faults and Failures</h3>
<p>We call a <strong>failure</strong> the inability of the system to
deliver the expected service, and a <strong>fault</strong> the cause of
that failure.</p>
<p><strong>Example:</strong> if a cash machine delivers the wrong amount
of money, we can say that the system has failed.</p>
<p>A fault causes an <strong>error</strong> in the state of the system,
which lead to a <strong>failure</strong>. A failure can have different
nature, such as physical, logical, human error or even as consequence of
an attack.</p>
<p><strong>Example: Logic Bomb.</strong> It’s a piece of code that is
inserted into a software system that will execute a malicious function
when specified conditions are met.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>legitimate_code<span class="op">();</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>date <span class="op">==</span> <span class="st">&quot;01/01/2020&quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    crash_system<span class="op">();</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>legitimate_code<span class="op">();</span></span></code></pre></div>
<p>Computer Faults vs. Other Equipment Faults Computer faults differ
from those of other equipment in several ways:</p>
<ul>
<li><strong>Subtler Failures</strong>: computer failures are more subtle
than outright crashes or sudden stops.</li>
<li><strong>Information Storage</strong>: computers store information in
various ways, leading to a multitude of possible errors, both internally
and externally.</li>
<li><strong>Hidden Small Defects, Big Effects</strong>: even small
hidden defects can have significant impacts, especially in digital
systems.</li>
<li><strong>Complex Hierarchies</strong>: computer systems are intricate
hierarchies built upon hidden components.</li>
</ul>
<h3 id="achieving-dependability">Achieving Dependability</h3>
<p>The dependability of a system can be achieved going trough a rigorous
and engineered steps. Two main figures are involved, system and software
engineers:</p>
<ul>
<li><strong>System engineers</strong> are responsible for the design of
the system, and they have to use analysis to model the dependability of
the their design. From these, the software specifications are derived,
and the possible changes to the system are evaluated, in order to
accomodate software limitations;</li>
<li><strong>Software engineers</strong> are responsible for the
implementation of the software, and they have to use the specifications
to develop the software, and to test it in order to verify that it meets
the requirements.</li>
</ul>
<p>In general, it’s crucial to understand that <strong>dependability is
not something that can be added to a system as an afterthought</strong>.
It must be considered from the very beginning of the design process, and
it must be an integral part of the system, wusing a scientific and
engineering approach.</p>
<h2 id="the-system-entity">The <em>system</em> entity</h2>
<p>A simple but effective definition of a system is the following: a
system is a entity that interacts with the environment and other
systems; its boundaries are the common frontier between the system and
the environment.</p>
<h3 id="systems-properties">System’s properties</h3>
<p>A system has a <strong>function</strong>, which is the service that
it provides to the environment, and it’s described by its own functional
specification. It also has a <strong>behavior</strong>, visualized as
the sequence of states that the system goes through during its
operation, and it’s how the system implements its function. Then there
is the <strong>structure</strong>, which is the way the system is
organized, and it’s described by its own structural specification.</p>
<p>From the user point of view, the system has a <strong>delivered
service</strong>, which is the result of the interaction between the
user and the system, that is the behavior of the system as perceived by
the user. Obviously, the user can be seen as another system that
interacts with the system under consideration.</p>
<h3 id="systems-requirements">System’s requirements</h3>
<p>First of all, we need to define the problem that the system has to
solve, and then we have to define the requirements that the system has
to meet, and then we have to define both functional and dependability
requirements. Pay attention to the difference between the system’s
function and the system’s specification: the former is the service that
the system provides, while the latter is the solution implemented to
provide that service. In the end, we define the
<strong>correctness</strong> of the system, which is the ability of the
system to deliver the specified service.</p>
<h2 id="dependability-tree">Dependability tree</h2>
<p>Take in consideration the following dependability tree:</p>
<figure>
<img src="../images/01/dependability%20tree.png" width="500"
alt="Dependability tree - Avizienis et al., 2004" />
<figcaption aria-hidden="true">Dependability tree - Avizienis et al.,
2004</figcaption>
</figure>
<h3 id="threats-to-dependability">Threats to dependability</h3>
<p>As we said before, a <strong>correct service</strong> is delivered if
the service is delivered in accordance with the system’s specification.
When this doesn’t happen, we have a <strong>service failure</strong>,
which is one the possible states of the system:</p>
<figure>
<img src="../images/01/states.png" width="500"
alt="Service failure - C. Bernardeschi" />
<figcaption aria-hidden="true">Service failure - C.
Bernardeschi</figcaption>
</figure>
<p>We call <strong>service outage</strong> the period during which the
system is not able to deliver the service, a <strong>service
degradation</strong> the period during which the system delivers a
service that is not in accordance with the specification, such as a
subset of the services. We also recall the <strong>chain of
threats</strong> to dependability: <strong>faults</strong> causes
<strong>errors</strong>, which lead to <strong>failures</strong>: note
that many errors don’t cause failures because they don’t reach the
external state of the system.</p>
<p>Faults can be <strong>dormant</strong>, that is they are present in
the system but they don’t cause errors, and <strong>active</strong>,
that is they cause errors, and thay can be <strong>external</strong> or
<strong>internal</strong>: from the latter we can extract the definition
of <strong>vulnerability</strong>, which is the property of the system
that allows an external agent to cause a fault.</p>
<p><strong>Example: Trapdoor.</strong> It’s a hidden entry within a
system that allows an attacker to bypass security measures.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>username <span class="op">=</span> read_username<span class="op">();</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>password <span class="op">=</span> read_password<span class="op">();</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>username <span class="op">==</span> <span class="ch">&#39;d</span><span class="er">ummy_user</span><span class="ch">&#39;</span><span class="op">){</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//note that the password is not checked</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    grant_access<span class="op">();</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>username<span class="op">.</span>isValid<span class="op">()</span> <span class="op">&amp;&amp;</span> password<span class="op">.</span>isValid<span class="op">()){</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    grant_access<span class="op">();</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>From the past example we can learn that, having in mind the
dependability tree, to achieve security only the authorized actions have
to be allowed, and the confidentiality and the integrity of the data
have appears in case of improper or unauthorized actions.</p>
<h3 id="dependability-attributes">Dependability attributes</h3>
<p>The dependability of a system can be described by a set of
attributes, measurable and quantifiable in terms of probabilities:</p>
<ul>
<li><strong>Availability</strong>: the readiness for correct
service;</li>
<li><strong>Reliability</strong>: the continuity of correct
service;</li>
<li><strong>Safety</strong>: the absence of catastrophic consequences on
the user and the environment;</li>
<li><strong>Confidentiality</strong>: the absence of unauthorized
disclosure of information;</li>
<li><strong>Integrity</strong>: the absence of improper system state
alterations;</li>
<li><strong>Maintainability</strong>: the ability to undergo
modifications and repairs.</li>
</ul>
<p>We also briefly present the concept of <strong>trust</strong> between
systems, that express the dependance of dependability of the system A
from the dependability of the system B.</p>
<p>From them, we can gave a new definition of dependability, based on
the frequency of the service failures:</p>
<blockquote>
<p>Dependability is the ability of the system to deliver the service in
accordance with the specification, avoiding that service failures occur
with a frequency that is greater than a certain threshold.</p>
</blockquote>
<p>The threshold should be derived from the system requirements, and
should consider frequency, duration and severity of the service
failures.</p>
<h2 id="taxonomy-of-faults">Taxonomy of faults</h2>
<h3 id="the-system-life-cycle">The system life cycle</h3>
<p>We define the <strong>system life cycle</strong> as the period of
time that starts from the conception of the system and continues until
the system is decommissioned. We’re going to consider only two phases of
the system life cycle: the <strong>development phase</strong>, during
which the system is designed and implemented, and the <strong>use
phase</strong>, during which the system is used to deliver the
service.</p>
<h4 id="development-phase">Development phase</h4>
<p>In this phase the system only interact with the <strong>development
environment</strong>, such as physical world, human developers, their
tools and possible facilities: in this phase development faults can be
introduced in the system.</p>
<h4 id="use-phase">Use phase</h4>
<p>In this phase the system interacts with the <strong>use
environment</strong>:</p>
<ul>
<li><strong>Physical environment</strong>: the system is subject to
physical stress, such as temperature, humidity, vibrations, etc;</li>
<li><strong>administrator</strong>: who manages the system;</li>
<li><strong>users</strong>: who interact with the system;</li>
<li><strong>providers</strong>: who delivers the system to the
users;</li>
<li><strong>infrastructure</strong>: everything that is needed to
support the system;</li>
<li><strong>intruders</strong>: who try to attack the system.</li>
</ul>
<p>The use phase alternates period of <strong>correct delivery</strong>
of the service, <strong>service outage</strong> and <strong>service
shutdown</strong>:</p>
<ul>
<li><strong>service outage</strong>: when the system has a service
failure, and it’s not able to deliver the service correctly;</li>
<li><strong>service shutdown</strong>: when the system is stopped for
maintenance or for other reasons. Note that maintenance may take place
during every period of time, and includes both repair and
modification.</li>
</ul>
<p>In fact, there is a taxonomy for the maintenance: if the system is
stopped for repair an active fault, then we have a <strong>corrective
maintenance</strong>; if the system is stopped for repair a dormant
fault, then we have a <strong>preventive maintenance</strong>; if the
system is stopped for modification, then we have an <strong>adaptive
maintenance</strong>, or <strong>augmentative maintenance</strong> if
the system is stopped for improvement.</p>
<p>$$</p>
<h3 id="faults-classification">Faults classification</h3>
<p>Given the fact that faults can’t be enumerated, it’s useful to
classify them in order to understand their nature and their effects,
because we can also identify the mechanisms that can be used to prevent
that specific class of faults.</p>
<figure>
<img src="../images/01/fault%20classification.png" width="400"
alt="Faults classification - Avizienis et al., 2004" />
<figcaption aria-hidden="true">Faults classification - Avizienis et al.,
2004</figcaption>
</figure>
<p>We identifies three main classes of faults:</p>
<ul>
<li><strong>development faults</strong>: faults that are introduced
during the development phase;</li>
<li><strong>physical faults</strong>: faults that affect the physical
components of the system;</li>
<li><strong>interaction faults</strong>: faults that includes all the
external faults.</li>
</ul>
<p>Overlapping classes are possible, so we’re able to identify 31
possible combinations of faults.</p>
<figure>
<img src="../images/01/fault%20combinations.png" width="400"
alt="Faults classification - Avizienis et al., 2004" />
<figcaption aria-hidden="true">Faults classification - Avizienis et al.,
2004</figcaption>
</figure>
<p>We’re going to analyze the most important classes of faults, having
in mind the previous figure.</p>
<h4 id="natural-faults">Natural faults</h4>
<p>They’re the faults numbered from <span
class="math inline">\(11\)</span> to <span
class="math inline">\(15\)</span> in the previous figure, and they’re
are mainly hardware faults caused by natural phenomena, without the
intervention of humans.</p>
<ul>
<li><strong>Production defect</strong>, <span
class="math inline">\(11\)</span>: a fault that is introduced during the
development;</li>
<li><strong>internal defect</strong>, <span class="math inline">\(12
\text{ and } 13\)</span>: a fault that is introduced during the use
phase, and it’s caused by the physical degradation of the
components;</li>
<li><strong>external defect</strong>, <span class="math inline">\(14
\text{ and } 15\)</span>: a fault that is introduced during the use
phase, and it’s caused by the physical stress of the environment,
outside the system boundaries.</li>
</ul>
<h4 id="human-made-faults">Human-made faults</h4>
<p>We can distinguish between <strong>malicious faults</strong>,
introduced with the intent to harm the system, and <strong>non-malicious
faults</strong>, introduced without any malicious intent.</p>
<p>The formers have as a goal to harm the system, the latter are divided
in two more classes:</p>
<ul>
<li><strong>non-deliberate faults</strong>: faults that are introduced
as human errors (<span class="math inline">\(1 \text{, } 2 \text{, } 7
\text{, } 8 \text{, } 16 \text{-}18 \text{, }
26\text{-}28\)</span>);</li>
<li><strong>deliberate faults</strong>: faults that are introduced as a
consequence of a deliberate action, such as a bad decision (<span
class="math inline">\(3 \text{, } 4 \text{, } 9 \text{, } 10 \text{, }
19 \text{-}21 \text{, } 29\text{-}31\)</span>).</li>
</ul>
<p>The latter can be introduced during <strong>development</strong> or
by <strong>interaction</strong>:</p>
<ul>
<li><strong>deliberate development faults</strong>: are generally the
result of a trade-off, both in terms of performance and economy (<span
class="math inline">\(3 \text{, } 4 \text{, } 9 \text{, }
10\)</span>);</li>
<li><strong>deliberate interaction faults</strong>: when operational
procedures are deliberately violated (<span class="math inline">\(19
\text{-}21 \text{, } 29\text{-}31\)</span>).</li>
</ul>
<p>In general, <strong>deliberate faults</strong> shows up only after an
unacceptable behavior of the system, and it can be difficult to realize
the actual faults because, when it happened, who introduced the fault
can be not conscious of the consequences of his action.</p>
<p>However, not all mistakes and dab decisions by non-malicious humans
are accidental: we can distinguish between <strong>accidental
faults</strong> and <strong>incompetence faults</strong>.</p>
<h4 id="interaction-faults">Interaction faults</h4>
<p>They can also be named as <strong>operational faults</strong>, given
the fact that they occour during the use phase, and they’re all
external, because they’re caused by the interaction between the system
and the environment. Classes from <span
class="math inline">\(16\)</span> to <span
class="math inline">\(31\)</span> are human made, and only <span
class="math inline">\(14\)</span> and <span
class="math inline">\(15\)</span> are natural.</p>
<p>A common feature of these faults is the fact that they usually need
the presence of a vulnerability in the system, that is a property of the
system that allows an external agent to cause a fault, both intentional
and unintentional.</p>
<p>Lastly, we recognize the <strong>permanent faults</strong>, that are
continuous and stable, and the <strong>transient faults</strong>, that
are temporary, even for very short periods of time.</p>
<h2 id="failures">Failures</h2>
<p>In order to characterize the failures, we use four different
dimensions, such that each of them can describe a different aspect of
the failure.</p>
<h3 id="failure-domain">Failure domain</h3>
<p>This point of view leads us to distinguish between <strong>content
failures</strong>, that are the result of the system’s inability to
deliver the correct service, and <strong>timing failures</strong>, that
are the result of the system’s inability to deliver the correct service
at the correct time (early, late, or never).</p>
<h3 id="consistency-domain">Consistency domain</h3>
<p>When a system has more than one user, it’s important to understand if
a failure shows up identically for each user, and we call this situation
<strong>consistent failure</strong>, or if the failure shows up
differently for each user, and we call this situation
<strong>inconsistent failure</strong>.</p>
<h3 id="detectability-domain">Detectability domain</h3>
<p>It’s the property of the system to check the correctness of the
service, and it’s the ability of the system to detect the failure. These
mechanisms have two failure modes:</p>
<ul>
<li><strong>false alarm</strong>: the system detects a failure when
there isn’t;</li>
<li><strong>missed detection</strong>: the system doesn’t detect a
failure when there is.</li>
</ul>
<h3 id="consequences-domain">Consequences domain</h3>
<p>Consequences of a failure are divided in two classes, based on their
severity and impact:</p>
<ul>
<li><strong>minor failure</strong>: the failure has a similar cost to
the benefit of the service;</li>
<li><strong>catastrophic failure</strong>: the failure has a cost that
is much greater than the benefit of the service.</li>
</ul>
<h3 id="criteria-to-evaluate-the-severity-of-a-failure">Criteria to
evaluate the severity of a failure</h3>
<p>We can use the following criteria to evaluate the severity of a
failure:</p>
<ul>
<li><strong>availability</strong>: the duration of the service
outage;</li>
<li><strong>safety</strong>: possible loss of life or injury;</li>
<li><strong>confidentiality</strong>: possible unauthorized disclosure
of information;</li>
<li><strong>integrity</strong>: data corruption and/or inability to
recover;</li>
</ul>
<h3 id="system-failures">System failures</h3>
<p>When a system has a failure, it is usually caused by different
coexisting faults; we talk about <strong>single fails</strong> if the
failure is caused by a single fault, and <strong>multiple fails</strong>
if the failure is caused by multiple faults. In the latter we can also
divide the faults in <strong>independent</strong> and
<strong>dependent</strong>, respectively if the faults are not related
to each other, and if the faults have a common cause.</p>
<h3 id="dependability-and-security-failures">Dependability and security
failures</h3>
<p>These failures occurs if the system suffers service failures more
frequently than an acceptable threshold; even the specifications of the
system can contain faults:</p>
<ul>
<li><strong>omission</strong>: a requirement is not included in the
specification;</li>
<li><strong>unjustified requirements</strong>: choice of requirements
that are not justified by the system’s function, that raises the cost of
the system.</li>
</ul>
<p>Systems can have different type of failures:</p>
<ul>
<li><strong>fail-controlled</strong>: the system is designed to fail in
a controlled way, described by the system’s specification;</li>
<li><strong>fail-stopped</strong>: the system in which possible failures
are only <em>haltings</em>;</li>
<li><strong>fail-silent</strong>: the system in which possible failures
are only <em>silents</em>;</li>
<li><strong>fail-safe</strong>: the system in which there are only minor
failures;</li>
</ul>
<h2 id="errors">Errors</h2>
<p>As we saw, an error is a part of the system state that is able to
lead to a failure. An error is detected if a signal to indicate its
presence in raised, otherwise the error is undetected and it’s called
<strong>latent error</strong>. It’s not true that every error leads to a
failure, and this depends on:</p>
<ul>
<li>the <strong>structure of the system</strong>, specially the presence
of redundancy;</li>
<li>the <strong>behavior of the system</strong>, for example the part of
the state that contains the error is never reached during the delivery
of the service, then the error is not able to lead to a failure.</li>
</ul>
<p>The classification of the error is done according to the damage
pattern (single, double or triple bit, burst, etc.), and how many
components are affected by the error (single, multiple, etc.).</p>
<h2
id="chain-of-threats---relationship-between-faults-errors-and-failures">Chain
of threats - Relationship between faults, errors and failures</h2>
<p>When systems have to interact with each other, an error propagation
can occur:</p>
<figure>
<img src="../images/01/chain%20of%20threats.png" width="400"
alt="Chain of threats - Avizienis et al., 2004" />
<figcaption aria-hidden="true">Chain of threats - Avizienis et al.,
2004</figcaption>
</figure>
<p>An <strong>active fault</strong> is when it leads to an error, both
if it’s internal or external, and it can lead to a failure, and a
<strong>fault activation</strong> occurs when a particular input
activates a dormant fault in a specific component. This can also be a
<strong>propagation</strong> between the components, where an error of a
component can lead to an error of another component.</p>
<p><strong>Example</strong>: error propagation</p>
<blockquote>
<p>Take a sensor which reports the spinning speed of a turbine. If the
sensor fails and starts to report that the turbine is no longer
spinning, it inject incorrect data (fault) into the control system, that
will send to the turbine the wrong commands, and the turbine could be
damaged (failure).</p>
</blockquote>
<h2 id="dependability-means">Dependability means</h2>
<p>When we talk about dependability means, we refer to the mechanisms
that are used to prevent, detect and tolerate, or in general deal, with
faults.</p>
<h3 id="fault-prevention">Fault prevention</h3>
<p>These techniques are usually related to general system design, and
they’re used to avoid the introduction of faults in the system. They can
be divided in two classes:</p>
<ul>
<li><strong>development fault prevention</strong>: techniques that are
used to avoid the introduction of faults during the development
phase;</li>
<li><strong>improved development process</strong>: techniques that are
used to improve the development process, such as the use of formal
methods, the use of a rigorous testing and so on.</li>
</ul>
<h3 id="fault-tolerance">Fault tolerance</h3>
<p>It’s the ability to deal with faults at run-time, and ensure that the
system is able to deliver the service even in presence of faults. There
are a lot of techniques that can be used to achieve fault tolerance, as
we can see in the following figure:</p>
<figure>
<img src="../images/01/tolerance.png" width="400"
alt="Fault tolerance techniques - Avizienis et al., 2004" />
<figcaption aria-hidden="true">Fault tolerance techniques - Avizienis et
al., 2004</figcaption>
</figure>
<h4 id="example-of-error-detection">Example of error detection</h4>
<p>For simplicity, let’s state that <em>when the error reaches the
boundaries of the systems, then we have a failure</em>. In this context,
the most challenging aspect are:</p>
<ul>
<li>the <strong>identification of the error</strong>, that is the
ability to detect the presence of the error;</li>
<li><strong>ensure that status containing the error is never
reached</strong>, that is the ability to avoid that the error leads to a
failure;</li>
<li>the <strong>prevention of the error propagation</strong>, that is
the ability to avoid that the error of a component leads to the error of
another component.</li>
</ul>
<p><strong>Example</strong>: error detection with two systems</p>
<blockquote>
<p>Take two systems, A and B, that should provide the same service. If
they get the same input, then they should provide the same output. If
the outputs are different, then we have a detection of the error, within
the hypothesis that the systems are independent and it’s very unlikely
that they have the same error at the same time.</p>
</blockquote>
<h3 id="fault-handling">Fault handling</h3>
<p>When we talk about fault handling, we refer to the mechanisms that
<strong>prevents faults from being activated again</strong>. It’s
composed by different phases:</p>
<ol type="1">
<li><strong>diagnois</strong>: the phase in which the system detects the
presence of the fault. Usually, a component is made in order to test
another components, and the aim is to identify and records the cause of
the error, in terms of location and type;</li>
<li><strong>isolation</strong>: to obtain the physical and/or logical
exclusion of the faulty component from the rest of the system;</li>
<li><strong>reconfiguration</strong>, such as thw switch to a redundant
component, or the use of a different path to reach the same
component;</li>
<li><strong>reinitialization</strong>: to restore the system to update
the system to the new configuration.</li>
</ol>
<p>In conclusion we state that the <strong>system recover is composed by
the error handling phase and the fault handling phase</strong>.</p>
<h3 id="fault-removal">Fault removal</h3>
<p>The fault removal is the process that is used to remove the faults
from the system, and it’s usually done during the development phase. The
main goal is to remove the faults that are present in the system, and to
prevent the introduction of new faults. It’s composed by different
phases, that we’ll see in the next sections:</p>
<h4 id="verification-phase">Verification phase</h4>
<p>The verification phase is the phase in which the system is tested to
verify that it meets the <strong>verification conditions</strong>. To do
that, there are two main methods:</p>
<ul>
<li>verification <strong>without execution</strong>: the system is
tested without executing it, and it’s usually done via inspection or
theory-proving. A state-transition diagram can be used to verify the
correctness of the system, and it’s applicable to various type of the
system, and applicable to fault tolerance mechanisms. Worth to mention
the fact that, in this type of verification errors and faults are
artificially injected as part of the test pattern;</li>
<li>verification <strong>by execution</strong>: the system is tested by
executing it, and it’s usually done via <strong>dynamic
verification</strong> (e.g. symbolic execution, testing both for
hardware and software), <strong>deterministic testing</strong> and
<strong>statistical testing</strong>.</li>
</ul>
<p>Another two steps are crucial:</p>
<ul>
<li><strong>verification of the mechanism</strong>: the verification of
the fault tolerance mechanism, and it’s usually done via <strong>fault
injection</strong>;</li>
<li><strong>verification of the system</strong>: ensure that the system
cannot do more than what is supposed to do, and it’s usually done via
<strong>penetration testing</strong>.</li>
</ul>
<p>To remove a fault during the exercise, both <strong>corrective
maintenance</strong> and <strong>preventive maintenance</strong>.</p>
<h3 id="fault-forecasting">Fault forecasting</h3>
<p>The fault forecasting is done by performing an evaluation of the
system behavior, with respect to fault occurrence and activation, and
it’s usually done via <strong>qualitative evaluation</strong> and
<strong>quantitative evaluation</strong>.</p>
<h3 id="error-recovery">Error recovery</h3>
<h4 id="error-compensation">Error compensation</h4>
<p>When we talk about fault tolerance, we’re in fact talking about
<strong>fault masking</strong>: a general method to achieve this goal is
<strong>performing multiple computations</strong> trough replicas, and
then apply a vote mechanism to the results. It’s worth to remember that
hardware faults <strong>fails independently</strong> and, on the
contrary, software faults <strong>fails dependently</strong>: to achieve
a sort of independence, we can use <strong>design diversity</strong>,
that is the use of different design techniques to implement the same
function.</p>
<p><strong>Example</strong>: error compensation with TMR</p>
<blockquote>
<p>Take a system that uses a <strong>Triple Modular Redundancy</strong>
(TMR) to achieve fault tolerance. The system has three replicas, and the
output is the result of a majority vote. If one of the replicas fails,
then the output is still correct, because the other two replicas are
still able to provide the correct output.</p>
</blockquote>
<h4 id="organization-of-fault-tolerance">Organization of fault
tolerance</h4>
<p>We can summarize the organization of fault tolerance in the following
figure:</p>
<figure>
<img src="../images/01/summary.png" width="400"
alt="Organization of fault tolerance - Avizienis et al., 2004" />
<figcaption aria-hidden="true">Organization of fault tolerance -
Avizienis et al., 2004</figcaption>
</figure>
<p>WE just have to add some definitions:</p>
<ul>
<li><strong>solid faults</strong> are those that are permanent and their
activation is repeatable;</li>
<li><strong>elusive faults</strong> are those that are permanent and
their activation is not systematically reproducible;</li>
<li><strong>intermittent faults</strong> are those with transient
physical or interaction faults, and their activation is not
systematically reproducible.</li>
</ul>
<p>Remember that the classes of faults that can be actually tolerated
depend on the fault assumption that is being considered in the
development process, and on the independence of the redundant components
that are used to achieve fault tolerance.</p>
<h2 id="error-detection">Error detection</h2>
<p>The error detection is the ability of the system to detect the
presence of an error, and different strategies can be used to achieve
this goal, such as:</p>
<ul>
<li><strong>replication checks</strong>: the use of multiple replicas to
perform the same computation, and then compare the results, under the
assumption that the replicas fail independently;</li>
<li><strong>reasonability checks</strong>: the use of a model of the
system to check the reasonability of the output, and then compare the
output with the model;</li>
<li><strong>run-time checks</strong>: mechanisms provided via hardware
or software, like division by zero, array bounds, etc.</li>
<li><strong>specification-based checks</strong>: the use of the problem
specification to check the correctness of the output (e.g. to find a
solution to an equation, we can substitute the result in the equation
and check if the result is correct);</li>
<li><strong>reversal checks</strong>: the use of the inverse function to
check the correctness of the output.</li>
<li><strong>structural checks</strong>: the use of known properties of
the system to check the correctness of the output.</li>
<li><strong>timing checks</strong>: the use of watchdogs to check the
timing of the system.</li>
<li><strong>codes</strong>: the use of codes to check the correctness of
the output (e.g. parity, checksum, etc.).</li>
</ul>
<h3 id="structural-approach-to-error-detection">Structural approach to
error detection</h3>
<p>The main goal is to prevent the propagation of the error, and to
achieve that some structural properties should be set to help the
system.</p>
<h4 id="principle-of-least-privilege">Principle of least privilege</h4>
<p>the concept of <strong>minimum privilege</strong> is crucial, and
it’s the idea that a component should have the minimum privilege to
perform its function, and nothing more. Following this idea, we should
consider the fact that <strong>no action is permissible unless it is
explicitly allowed</strong>, also known as the concept of <strong>mutual
suspicion</strong>.</p>
<h4 id="system-modularization-and-partitioning">System modularization
and partitioning</h4>
<p>Remembering the fact that a system should be modularized, we can use
the <strong>modularization</strong> to prevent the propagation of the
error, adding to each module an error detection (and possibly recovery)
mechanism, in order to confine the error to the module in which it
occurred and don’t let it spread to the other modules. The last
reasoning is also valid for the <strong>partitioning</strong> of the
system, when modules act independently and the error can’t spread to the
other modules.</p>
<h4 id="temporal-structuring">Temporal structuring</h4>
<p>Another thing to take in consideration is the <strong>temporal
structuring</strong> of the activities between the modules, for those
operations only between two specific modules that don’t communicate with
the rest of the system. We also introduce the concept of <strong>atomic
action</strong>, that is an action that is performed in a single step,
and it’s not possible to interrupt it: if a failure occurs, only the
participating actions are affected.</p>
<h3 id="measurement-of-effectiveness-of-error-detection">Measurement of
effectiveness of error detection</h3>
<p>Different metrics can be used to measure the effectiveness of the
error detection, such as:</p>
<ul>
<li><strong>coverage</strong>: the probability that an error is
detected, given that it actually occurs;</li>
<li><strong>latency</strong>: the time that elapses between the
occurrence of the error and its detection;</li>
<li><strong>damage confinement</strong>: the probability that the error
is confined to the component in which it occurred;</li>
<li><strong>forward recovery</strong>: the probability that the system
is able to recover from the error, transforming the erroneous state into
a <strong>new</strong> correct state;</li>
<li><strong>backward recovery</strong>: the probability that the system
is able to recover from the error, transforming the erroneous state into
the <strong>previous</strong> correct state.</li>
</ul>
<p>It’s worth to spent some words for the last two metrics, that will be
discussed in the next section.</p>
<h4 id="forward-recovery">Forward recovery</h4>
<p>This technique requires to <strong>asses the damage cause</strong> by
the detected error <strong>propagates before detection</strong>, and
it’s usually implemented ad-hoc for the specific system. An effective
<strong>example</strong> is the following:</p>
<blockquote>
<p>In a real time control system, a situation when input a sensor input
is occasionally missed is tolerable, and the system should implement a
forward recovery by skipping its response of the missed input.</p>
</blockquote>
<h4 id="backward-recovery">Backward recovery</h4>
<p>This technique is a little bit more complex, because <strong>requires
a previous correct state</strong> to be restored, also called
<strong>checkpoint</strong>, and can be tedious, especially in case when
multiple modules are involved, because we need to restore a
<strong>consistent checkpoint</strong> for each of them, as we can see
in the following figure:</p>
<figure>
<img src="../images/01/backwards.png" width="400"
alt="Backward recovery - C. Bernardeschi" />
<figcaption aria-hidden="true">Backward recovery - C.
Bernardeschi</figcaption>
</figure>
<p>In this image we see the checkpoint, as circle, the passed messages
between the modules, and the error that occurs with a <span
class="math inline">\(X\)</span>: to avoid a <strong>domino
effect</strong>, we need to restore a consistent checkpoint for each
module, also considering their communications, remembering the concept
of atomic action.</p>
<p>The basic issues of backward recovery are:</p>
<ul>
<li>loss of computation time between the checkpoint and the
rollback;</li>
<li>loss of data between the checkpoint and the rollback;</li>
<li>the need of a specific mechanism that implements the rollback;</li>
<li>the increase of the overhead of the system, in order to restore the
correct state.</li>
</ul>
<p>The class of faults that gain benefits from the backward recovery are
the <strong>transient faults</strong>, because they usually disappear
after a short period of time, in <strong>parallel computing</strong>, to
avoid a complete restart of the system, and in <strong>real-time
systems</strong>, to avoid the loss of the real-time constraints.</p>
<p>On the other hand, the class of faults that are not suitable for the
backward recovery are the <strong>hardware and design faults</strong>,
because the system will always do the same action, resulting in the same
error.</p>
<h3 id="the-exception-handling">The exception handling</h3>
<p>The exception handling is a mechanism that is used to deal with the
errors, and it’s usually implemented via software, and it’s used to deal
with the errors that are detected at run-time. The main goal of the
exception handling is to avoid the propagation of the error, and to
restore the system to a consistent state. Three are the main classes of
exceptions:</p>
<ul>
<li><strong>interface exceptions</strong>: exceptions that are raised
when the system receives an input that is not in accordance with the
specification, handled by the module that requests the service;</li>
<li><strong>internal local exceptions</strong>: exceptions that are
raised when the system detects an error in its own state, handled by the
module itself;</li>
<li><strong>failure exceptions</strong>: exceptions that are not handled
by the mechanism, communicated to the user.</li>
</ul>
<h1 id="redundancy-in-fault-tolerant-computing">Redundancy in Fault
Tolerant Computing</h1>
<p>In this chapter we’ll se how to use redundancy to improve the
reliability of a system. There are various types of redundancy, and
we’ll go through them one by one.</p>
<h2 id="hardware-redundancy">Hardware Redundancy</h2>
<p>Briefly, hardware redundancy is the physical replication of the
hardware components of a system. This is done to ensure that if one
component fails, the system can continue to operate using the redundant
component. In this category we can find <strong>passive</strong>,
<strong>active</strong> and <strong>hybrid</strong> redundancy.</p>
<h3 id="passive-fault-tolerance-techniques">Passive fault tolerance
techniques</h3>
<p>In passive tolerance, the <strong>fault masking</strong> is the
keystone of the technique: a <strong>voting mechanism</strong> is
implemented upon the redundant components, and the output of the system
is the result of the majority of the components. This way, if one
component fails, the system can continue to operate using the redundant
component, and <strong>without any external intervention</strong>.</p>
<h4 id="triple-modular-redundancy-tmr">Triple Modular Redundancy
(TMR)</h4>
<p>This technique is schematized in the following figure:</p>
<figure>
<img src="../images/02/tmr.png" width="300"
alt="Scheme of a TMR implementation - C.Bernardeschi" />
<figcaption aria-hidden="true">Scheme of a TMR implementation -
C.Bernardeschi</figcaption>
</figure>
<p>The main idea is to <strong>triplicate</strong> the specific
component, and perform a <strong>majority voting</strong> on the
outputs. This technique obviously needs the assumption that the
<strong>probability of failure of the components is
independent</strong>, but ensure a fault neutralization without the need
of any external intervention, and this for each of the components.</p>
<p>TMR is very effective when we’re dealing with <strong>transient
faults</strong>, but on the contrary isn’t very helpful when dealing
with <strong>permanent faults</strong>, and this because the fault
tolerance decreases since the faulty component remains in the
system.</p>
<h4 id="cascaded-tmr-with-triplicated-voters">Cascaded TMR with
triplicated voters</h4>
<p>This technique is a further development of the TMR, and is
schematized in the following figure:</p>
<figure>
<img src="../images/02/CTMR.png"
alt="Scheme of a cascaded TMR with triplicated voters - C.Bernardeschi" />
<figcaption aria-hidden="true">Scheme of a cascaded TMR with triplicated
voters - C.Bernardeschi</figcaption>
</figure>
<p>The effect of partitioning the modules is that the design can now
withstands more failures than the TMR, thanks to the multiple voters.
Unfortunately, we can let this technique arbitrarily reliable, because
the reliability of the system is limited by the <strong>reliability of
the voters</strong>, which also are a <strong>single point of
failure</strong>.</p>
<h4 id="the-voter">The Voter</h4>
<p>The voter is a crucial component in the previous techniques: it’s
usually implemented as an hardware digital circuiting, and it’s
responsible for the majority voting. This leads to difficulties on its
implementation:</p>
<ul>
<li><strong>delay on signal propagation</strong>: the voter must wait
for the inputs to be stable before performing the voting, waiting for
the synchronization of the inputs;</li>
<li>trade-off between <strong>achieved fault tolerance</strong> and
<strong>cost</strong> in hardware complexity.</li>
</ul>
<p>There is also another main problem, that come out when we’re dealing
with <strong>analog signals</strong>: in this case, the majority voting
is not so straightforward, and the voter must be implemented as a
<strong>digital-to-analog converter</strong>. Given that these converter
could produce inconsistent results, another techniques are implemented
to ensure the correct voting, such as:</p>
<ul>
<li><strong>average of the signals</strong>;</li>
<li>choose the <strong>mean of similar signals</strong>;</li>
<li>choose the <strong>median of the signals</strong>.</li>
</ul>
<h4 id="n-modular-redundancy-nmr">N-Modular Redundancy (NMR)</h4>
<p>This technique is a generalization of the TMR, when the number of
redundant components, which <strong>must be odd</strong>, is arbitrary.
Using this method, we can cover up to <span
class="math inline">\(m\)</span> faulty modules, such that <span
class="math inline">\(N = 2m+1\)</span>. The main problem of this
technique is that the number of voters grows with the number of
redundant components, and this leads to a <strong>high
cost</strong>.</p>
<h3 id="active-fault-tolerance-techniques">Active fault tolerance
techniques</h3>
<p>In active tolerance, redundancy is used in a <strong>dynamic
way</strong>, through fault detection, location and recovery. Briefly,
the existence of faults is detected, and some actions are taken in order
to remove the faulty component from the system, and replace through a
reconfiguration. These techniques are used in context where temporary
faults while the system is being reconfigured are acceptable.</p>
<h4 id="duplication-with-comparison-scheme">Duplication with comparison
scheme</h4>
<p>Two identical pieces of hardware are used, performing the same
computation in parallel, with a comparator that takes as input their
results. If the results differs, a failure is detected and an error
signal is generated. The technique has a good coverage ratio, because
it’s able to detect <strong>every faults</strong>, except fot those that
affect the comparator: worth to mention is the simplicity and the low
cost, with a minimal impact on the performance. On the other hand, we
have to deal with the possibility that the comparator itself could
fails, leading to both false positives and false negatives.</p>
<h4 id="reconfigurable-duplication">Reconfigurable Duplication</h4>
<p>This technique is a further development of the previous one, and is
schematized in the following figure:</p>
<figure>
<img src="../images/02/ReconfDuplication.png"
alt="Scheme of a reconfigurable duplication - C.Bernardeschi" />
<figcaption aria-hidden="true">Scheme of a reconfigurable duplication -
C.Bernardeschi</figcaption>
</figure>
<p>The circuit works like the previous one, with the difference that the
output of the comparator is used as input of the switch, in order to
select the module that will be used as output, with the implicit
hypothesis that the comparator is able to select the correct value in
case of disagreement. To do that, checks such as coding, reversal or
reasonable checks are performed, and the switch is used to select the
correct output disconnecting the faulty module. This configuration is
also called <strong>duplex system</strong>.</p>
<h4 id="stand-by-sparing">Stand-by sparing</h4>
<p>As we can see in the schema, modules can be
<strong>operational</strong> or <strong>spares</strong>:</p>
<figure>
<img src="../images/02/spares.png" width="400"
alt="Scheme of a stand-by sparing - C.Bernardeschi" />
<figcaption aria-hidden="true">Scheme of a stand-by sparing -
C.Bernardeschi</figcaption>
</figure>
<p>The switch implements the <strong>fault detection and
localization</strong>, and can decide to no longer use a module if it’s
faulty, and to replace it with a spare. Spares are divided in three
categories:</p>
<ul>
<li><strong>hot spares</strong>: they are always active, and ready to
replace a faulty module in every moment;</li>
<li><strong>warm spares</strong>: they are running, but receives inputs
from the system only when they are activated;</li>
<li><strong>cold spares</strong>: they are off, and must be activated
before being used.</li>
</ul>
<p>A <strong>pair-and-spare</strong> approach can also be used, when
every module is a <strong>duplex system</strong>, connected to the
switch with a comparator: as long as the outputs agree, the spares are
not used, but in case of disagreement, the switch operates the
replacement.</p>
<h3 id="hybrid-fault-tolerance-techniques">Hybrid fault tolerance
techniques</h3>
<p>In this category, we can find the <strong>combination</strong> of the
previous techniques, in order to obtain a better fault tolerance. The
main idea is to combine the advantages of the previous techniques, and
to mitigate their disadvantages. Intuitively, we can say that costs
increase dramatically, such as the complexity of the implementations, so
this techniques are used only in <strong>critical systems</strong>.</p>
<h4 id="reconfigurable-nmr">Reconfigurable NMR</h4>
<p>This technique is a combination of the NMR and the reconfigurable
duplication, and is schematized in the following figure:</p>
<figure>
<img src="../images/02/reconfNMR.png" width="300"
alt="Scheme of a reconfigurable NMR - C.Bernardeschi" />
<figcaption aria-hidden="true">Scheme of a reconfigurable NMR -
C.Bernardeschi</figcaption>
</figure>
<p>There are <span class="math inline">\(N\)</span> redundant modules,
and the voter; the <strong>fault detection units</strong> compare the
outputs of the voters with the output of the active modules, and replace
the faulty module with a spare, isolating it from the system. The
reliability of the circuit holds as longs as the number of spare modules
isn’t zero, and the coverages depends on the number of spare: a TMR with
one spare can tolerates up to two faults, by masking the first module,
replacing it and possibly mask the second one.</p>
<h3 id="summary-of-the-hardware-redundancy-techniques">Summary of the
hardware redundancy techniques</h3>
<p>The key differences between the techniques are summarized:</p>
<ul>
<li><strong>passive</strong> rely on the <strong>fault masking</strong>,
and requires high investments in the hardware;</li>
<li><strong>active</strong> rely on the <strong>error
detection</strong>, <strong>fault localization</strong> and
<strong>recovery</strong>, but has the disadvantage of needing
additional hardware to detect and recover from the faults, and can
produced <strong>transient errors</strong>;</li>
<li><strong>hybrid</strong> are a combination of the previous
techniques. The reliability of the system is increased, but the costs
are the highest.</li>
</ul>
<h2 id="information-redundancy">Information Redundancy</h2>
<p>When we talk about information redundancy, we’re referring to
<strong>coding</strong>, that is the application of the redundancy
within the information itself. This is done using more bits than
strictly necessary to represent the information: if <span
class="math inline">\(n\)</span> is the number of bits needed to
represent the information, we use <span class="math inline">\(m = n +
c\)</span> bits, such that among all the possible <span
class="math inline">\(2^m\)</span> combinations, only <span
class="math inline">\(2^n\)</span> represents acceptable information,
and these combinations are called <strong>codewords</strong>; if a
non-codeword is received, an error is detected.</p>
<p><strong>Coding</strong> needs a phase of <strong>encoding</strong>,
where the <span class="math inline">\(c\)</span> bit are calculated and
added to the information, and a phase of <strong>decoding</strong>,
where the information is extracted from the codeword. We refer to
<strong>separable code</strong> when the information and the redundancy
are clearly separated,such as a concatenation of the information and the
redundancy, and to <strong>non-separable code</strong> when the
information and the redundancy are mixed together.</p>
<h3 id="parity-codes">Parity codes</h3>
<p>The simplest form of coding is the <strong>parity code</strong>,
where a single bit is added to the information, such that the number of
1s in the codeword is even or odd. This technique is very simple, but is
able to detect only <strong>single bit errors</strong>, and can’t
correct them.</p>
<p><strong>Example</strong>:</p>
<blockquote>
<p>with <span class="math inline">\(n=2\)</span> and <span
class="math inline">\(m=3\)</span>, 8 are the possible combinations, and
4 are the codewords. We can easily get that the codewords are <span
class="math inline">\(001\)</span>, <span
class="math inline">\(010\)</span>, <span
class="math inline">\(100\)</span> and <span
class="math inline">\(111\)</span>.</p>
</blockquote>
<h3 id="complemented-duplication">Complemented duplication</h3>
<p>In this technique, the information is duplicated, having <span
class="math inline">\(n\)</span> bits of information and <span
class="math inline">\(n\)</span> bits of redundancy, such that the
redundancy is the complement of the information. In this case, having
<span class="math inline">\(n=4\)</span>, we can have 16 possible
combinations, and 4 are the codewords.</p>
<h3 id="hamming-distance">Hamming distance</h3>
<p>We define the <strong>Hamming distance</strong> has it follows:</p>
<blockquote>
<p>Given two codewords <span class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span>, the Hamming distance between them is
the number of bits in which they differ.</p>
</blockquote>
<p>The <strong>minimum Hamming distance</strong> between two codewords
is the number of independent single bit errors that the code can detect;
a code such that the Hamming distance is $ &gt; k$ will detect up to
<span class="math inline">\(k\)</span> erroneous bits.</p>
<p>The main concept is that <strong>the corrupted data is closer to the
correct data than to any other codeword</strong>. In the following
figure, we can see a generic example of the Hamming distance, with the
differences between predictable and unpredictable errors.</p>
<figure>
<img src="../images/02/hamming.png" width="300"
alt="Hamming distance - C.Bernardeschi" />
<figcaption aria-hidden="true">Hamming distance -
C.Bernardeschi</figcaption>
</figure>
<h3 id="checksums">Checksums</h3>
<p>This method is usually applied to large blocks of data, and it’s able
to cover a single fault. The checksum for a block of <span
class="math inline">\(n\)</span> words is formed by adding together all
the words modulo <span class="math inline">\(k\)</span>, with <span
class="math inline">\(k\)</span> arbitrary. The checksum is then stored
in the data block, and when the block is transmitted, the checksum is
recalculated and compared with the stored one; the codeword in this case
is composed by the entire block of data, and the actual checksum.</p>
<p>The main disadvantages of the technique are:</p>
<ul>
<li>the need to recalculate the checksum every time the data is
modified;</li>
<li>the error detection is limited is allowed, but the error
localization is not possible.</li>
<li>it represents a single point of failure.</li>
</ul>
<h3 id="ecc">ECC</h3>
<p>This technique enables the <strong>error location</strong> for
single-bit error, as we can see in the following figure:</p>
<figure>
<img src="../images/02/ECC.png" width="300"
alt="ECC - C.Bernardeschi" />
<figcaption aria-hidden="true">ECC - C.Bernardeschi</figcaption>
</figure>
<h3 id="hamming-codes">Hamming codes</h3>
<p>This technique is usually used in databases, with specific disks that
implements that mechanism, and it’s based on <strong>spreading parity
bits across the data</strong>. The main idea is to use the
<strong>parity bits</strong>, that are all bit in positions that are a
power of 2, to check the data, and to use the <strong>data bits</strong>
to store the information. In this way, the data bits are included in a
set of two or more parity bits, and the parity bits are included in a
set of two or more data bits, implementing a <strong>detection and
correction</strong> mechanism. In the figure we can see an example of
the Hamming code:</p>
<figure>
<img src="../images/02/hammingCode.png"
alt="Hamming code - Wikipedia" />
<figcaption aria-hidden="true">Hamming code - Wikipedia</figcaption>
</figure>
<p>The parity bit <span class="math inline">\(p_j\)</span> covers all
the bit whose position has the <span class="math inline">\(j\)</span>-th
bit set to 1, so every data bit is covered by a set of parity bits.</p>
<h3 id="self-checking-circuitry">Self-checking circuitry</h3>
<p>In order to implements all the previous methods, we have the
necessity of reliability on the modules that performs checks and
comparisons, and this is done through the <strong>self-checking
circuitry</strong>.: given a set of faults, the circuit has the ability
to <strong>automatically detect</strong> the fault, during the normal
course of its operations; this is usually achieved by implementing
coding techniques in the circuitry, such that input and outputs are
encoded. . Three are the main techniques:</p>
<ul>
<li><strong>self-testing</strong> circuitry: if, for every fault from
the set, does exists a non-code output;</li>
<li><strong>fault-secure</strong> circuitry: if, for every fault from
the set, the circuit never produces an incorrect output for any
input;</li>
<li><strong>totally self-checking</strong> circuitry: if the circuit is
both self-testing and fault-secure.</li>
</ul>
<h2 id="time-redundancy">Time Redundancy</h2>
<p>To avoid the need (and the expense) of additional hardware, we can
use another type of redundancy, called <strong>time redundancy</strong>:
the main idea is to exchange the <strong>expense of the
hardware</strong> with the <strong>expense of the time</strong>.</p>
<h3 id="repetition-of-the-computation">Repetition of the
computation</h3>
<p>If we implement the time redundancy in this way, we have to
<strong>perform multiple time</strong> the same computation: it appears
obvious that <strong>permanent faults cannot be detected</strong>, given
the fact that the latter lead the system to always have the same error,
but instead it’s effective against <strong>transient faults</strong>. We
have also the problem to guaranteeing that the computation is performed
in the same way and with the same data, and the non-negligible
overhead.</p>
<h2 id="software-redundancy">Software Redundancy</h2>
<p>As we briefly said in the previous chapter, the software is subject
to both <strong>operational faults</strong> and <strong>design
flaws</strong>. In particular, the latter is due to
<strong>ambiguities</strong> in the specifications, or in mistakes made
during the implementation. They’re hard to visualize, and they’re also
closely related to a human factor: if, for example, only specific inputs
trigger a fault, the number of failures depends on the number of times
the inputs are used; it’s also true that the <strong>apparent
reliability</strong> of a software is more due to the number of the
exercised design faults, rather than the actual number of design faults
present in the software. Given these premises, and the fact that the
software has a large cost of development, the main focuses of software
reliability are made on the <strong>fault prevention</strong> and
<strong>testing strategies</strong>, usually with a
<strong>multi-version</strong> approach.</p>
<h3 id="software-diversity">Software diversity</h3>
<p>Implementing two (or more) identical version of the software, these
versions will always fail not in a independent way, leading to an
inability to detect possible software faults. For this reason, the
versions must be <strong>diverse</strong>: they obviously must be
functionally equivalent, but their development must be carried out by
different teams, using different tools and different algorithms.
Developing <span class="math inline">\(N\)</span> different versions,
the need of a decision mechanism is necessary, and this is usually
implemented through a <strong>voting mechanism</strong>.</p>
<h4 id="disadvantages-and-practical-considerations">Disadvantages and
practical considerations</h4>
<p>When using software diversity, we have to deal with the higher cost
for development and concurrent execution of the software, and the
possibility to have <strong>correlated errors</strong>, due to
specification mistakes that shouldn’t be tolerated. A practical concern
over the voting mechanism is that every version will have different
compilers and formats for data types, that must be taking into account
when implementing the voting mechanism.</p>
<h3 id="n-version-programming">N-version programming</h3>
<h4 id="the-voter-1">The voter</h4>
<p>Some considerations we made in the previous sections, when we talked
about hardware redundancy, are also valid for software redundancy: the
voter is still a <strong>single point of failure</strong>, and it’s not
replicated, in order to remain simple and verifiable.</p>
<p>New tasks for the voter are that must <strong>verify the consistency
of input data</strong> within the different versions, and must be able
to receive data in a identical format from every version, both
implementing a communication protocol and/or a efficient data
conversion.</p>
<h4 id="n-version-self-check-programming">N-version self-check
programming</h4>
<p>This circuit is based on the <strong>acceptance tests</strong> rather
than the comparison between equivalent version: the voter implements
some sort of selection logic that takes as input only the results from
the versions whose output passed the specific-version acceptance tests,
tolerating up to <span class="math inline">\(N-1\)</span> faults.</p>
<h3 id="design-diversity">Design diversity</h3>
<p>This technique is based on the fact that the <strong>same
specification can be implemented in different ways</strong>, and the
different implementations can be used to check each other. The main idea
is to use different algorithms, data structures and programming
languages, and to use the same inputs to check the outputs.
Unfortunately, as we said before, it’s not possible to assume that these
versions will fail independently, and this is due to the fact that the
same specification can be implemented in different ways, but the same
design flaws can be present in the different implementations: it’s in
fact true that, from empirical studies, that common faults are pretty
common, but at the same time, implementing the diversity delivers actual
improvements in the reliability.</p>
<h1
id="basic-building-blocks-in-fault-tolerant-distributed-systems">Basic
building blocks in Fault tolerant distributed systems</h1>
<h2 id="atomic-actions">Atomic actions</h2>
<p>We intend as atomic an action that is indivisible, that is, it is
executed in its entirety or not at all. In a distributed system, an
atomic action is generally executed at more than one node, so these
nodes have to cooperate in order to guarantee the atomicity property: if
one of the nodes fails, the action shouldn’t let its effects be visible
to the entire system.</p>
<h3 id="atomic-actions-in-a-database">Atomic actions in a database</h3>
<p>In a database, an atomic action is a transaction, that can be
composed by more than one operation such as read, write, update or
deleted a record in the database.</p>
<h4 id="commit">Commit</h4>
<p>When a transaction is committed, all its effects are made visible to
the entire system. This means that the transaction is finished and its
effects are permanent. An example of a transaction is a bank transfer,
where the money is removed from one account and added to another
account, as we can see in the following example:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>t: <span class="cf">begin</span> <span class="kw">transaction</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UPDATE</span> <span class="kw">account</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> balance <span class="op">=</span> balance <span class="op">+</span> <span class="dv">500</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> account_number <span class="op">=</span> <span class="dv">45</span>;</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UPDATE</span> <span class="kw">account</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> balance <span class="op">=</span> balance <span class="op">-</span> <span class="dv">500</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> account_number <span class="op">=</span> <span class="dv">35</span>;</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>t: <span class="kw">commit</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span> <span class="kw">transaction</span></span></code></pre></div>
<h4 id="abort-or-rollback">Abort or Rollback</h4>
<p>When a transaction is aborted, all its effects are discarded and the
system is restored to the state it was before the transaction started.
An example of a transaction that is aborted is a bank transfer where the
money is added to one account but not removed from the other account
because of balance insufficiency, as we can see in the following
example:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>t: <span class="cf">begin</span> <span class="kw">transaction</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UPDATE</span> <span class="kw">account</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> balance <span class="op">=</span> balance <span class="op">+</span> <span class="dv">500</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> account_number <span class="op">=</span> <span class="dv">45</span>;</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UPDATE</span> <span class="kw">account</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> balance <span class="op">=</span> balance <span class="op">-</span> <span class="dv">500</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> account_number <span class="op">=</span> <span class="dv">35</span>;</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> balance</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">INTO</span> V <span class="kw">FROM</span> <span class="kw">account</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> account_number <span class="op">=</span> <span class="dv">35</span>;</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">IF</span> V <span class="op">&gt;=</span><span class="dv">0</span> <span class="cf">THEN</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">commit</span>;</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">ELSE</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        abort;</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">END</span> <span class="cf">IF</span>;</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>;</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span> <span class="kw">transaction</span></span></code></pre></div>
<h3 id="atomic-actions-in-a-distributed-system">Atomic actions in a
distributed system</h3>
<p>Imagine now that the bank database is distributed, and the two
accounts are stored in two different nodes. In this case, the
transaction has to use data stored in different nodes: a possible
rollback of the transaction must leave both nodes in a consistent state,
that is, the state they were in before the transaction started. Using
the previous codes as an example, the DBMS has to guarantee that if the
transaction is aborted, the money is not added to the first account and
the money is not removed from the second account, considering the fact
that these information are stored in different nodes.</p>
<h3 id="two-phase-commit">Two-phase commit</h3>
<p>The two-phase commit is a protocol that guarantees that a transaction
is either committed or aborted in a distributed system. We have some
crucial elements to consider:</p>
<ul>
<li>the <strong>transaction manager TM</strong>, that is the entity that
coordinates the transaction;</li>
<li>some <strong>resource managers RM</strong>, that are the entities
that manage the resources involved in the transaction.</li>
<li>a <strong>log file</strong>, stored in persistent memory, that is
used to recover the state of the transaction in case of failure;</li>
<li>a <strong>timeout</strong>, that is the maximum time that the TM
waits for a response from the RMs.</li>
</ul>
<p>A scheme of the two-phase commit is the following:</p>
<figure>
<img src="../images/03/twoPhase.png" width="400"
alt="Two-phase commit" />
<figcaption aria-hidden="true">Two-phase commit</figcaption>
</figure>
<p>In case of fail of the TM, we have an <strong>uncertain
period</strong>, during which a RM with a ready state cannot terminate
the transaction. Note that this mechanism is able to tolerates both loss
of messages and crash of nodes, simply rolling back the transaction.</p>
<h3 id="three-phase-commit">Three-phase commit</h3>
<p>This protocol is an evolution of the previous one, where a
<strong>pre commit</strong> phase is added. Assuming a permanent crash
of the TM, a participant is able to substitute the coordinate, in order
to terminate the transaction, with a <strong>global commit</strong> or a
<strong>global abort</strong>.</p>
<figure>
<img src="../images/03/threePhase.png" width="400"
alt="Three-phase commit" />
<figcaption aria-hidden="true">Three-phase commit</figcaption>
</figure>
<h3 id="recovery-and-atomicity">Recovery and atomicity</h3>
<p>Given a block <span class="math inline">\(B\)</span>, that can be a
<strong>physical block</strong> (a disk block) or a <strong>buffer
block</strong> (temporary storage in memory), the operations to move a
block from a disk to a buffer are <strong>input(B)</strong> and
<strong>output(B)</strong>. A transaction <span
class="math inline">\(T_i\)</span> has its own private work-area, in
which local copies of all accessed items are stored, performing the
operations <strong>read_item(X)</strong> and
<strong>write_item(X)</strong>. The system can perform the
<strong>output</strong> of the operation, trough the
<strong>output(<span class="math inline">\(B_X\)</span>)</strong>
operation, that need not immediately follows the
<strong>write_item(X)</strong> operation.</p>
<p>In general, several outputs are required by a transaction, and the
latter can be aborted after one of these operations have been made
permanent; it’s also true that a transaction can be committed, and a
failure can occur before all the outputs are made permanent. In order to
guarantee the atomicity property, the system has to perform the
<strong>output</strong> operation in a way that the transaction is
either committed or aborted, and the <strong>output</strong> operation
is either made permanent or not, using a <strong>log file</strong> to
recover the state of the transaction in case of failure.</p>
<h3 id="log-file">Log file</h3>
<p>The log file is a file stored in persistent memory, that is used to
recover the state of the transaction in case of failure. Before the
commit of a transaction, system has to save into the log file all the
records of the operations that have been made permanent, and after the
commit of a transaction, system has to save into the log file a record
that indicates the commit of the transaction, executing
<strong>UNDO</strong> and <strong>REDO</strong> operations in case of
failure, to restore the state of the transaction.</p>
<h2 id="consensus-problem">Consensus problem</h2>
<p>The consensus problem describes <strong>how a set of distributed
systems can agree on a value</strong>, despite failures; to help its
description, the <em>Byzantines Generals</em> metaphor is used. In this
scenario, generals must agree on an attack plan or a retreat, but not
all of them are loyal: we have the presence of traitors among them, who
may lie in order to influence the plan to take an advantage to the
enemies. Each general observes the enemy abd communicates their
observations to the others: traitors may lie in order to support their
own plan, or even misrepresent the observations of the loyal generals,
making it difficult to reach an agreement.</p>
<h3 id="the-byzantine-generals-problem">The Byzantine Generals
problem</h3>
<p>As we just said, generals can be loyal or traitors, and they reach
the consensus when:</p>
<ol type="1">
<li>all loyal generals agree on the same plan;</li>
<li>a small number of traitors cannot cause the loyal generals to adopt
a bad plan.</li>
</ol>
<h4 id="assumptions">Assumptions</h4>
<p>The general assumptions of the Byzantine Generals problem are:</p>
<ul>
<li>let <span class="math inline">\(n\)</span> be the number of
generals;</li>
<li>the opinion of a general is either <strong>attack</strong> or
<strong>retreat</strong>, described by the function <span
class="math inline">\(v(i)\)</span>;</li>
<li>each general <span class="math inline">\(i\)</span> share their
value <span class="math inline">\(v(i)\)</span> to each other
general;</li>
<li>each general final decision is obtained by a majority vote among the
opinions shared by the generals.</li>
</ul>
<h4 id="role-of-the-traitors">Role of the traitors</h4>
<p>We have <strong>absence of traitors</strong> when the generals have
the same value <span class="math inline">\(v(1), v(2), ...,
v(n)\)</span>, a situation that results in taking the same decision. On
the contrary we have <strong>presence of traitors</strong> when the
generals have different values, and the traitors can influence the
decision of the loyal generals. In particular, in presence of
traitors:</p>
<ul>
<li>to satisfy the first condition, the loyal generals have to agree on
the same value. In other words, every general must apply the majority
function to the same set of values <span class="math inline">\(v(1),
v(2), ..., v(n)\)</span>;</li>
<li>to satisfy the second condition, for each general <span
class="math inline">\(i\)</span>, if they are loyal, the the value they
<span class="math inline">\(v(i)\)</span> they sent must be used by
every loyal general as the value of general <span
class="math inline">\(i\)</span>.</li>
</ul>
<h4 id="interactive-consistency">Interactive consistency</h4>
<p>Interactive consistency is a concept where a commanding general <span
class="math inline">\(C\)</span> and <span
class="math inline">\(n-1\)</span> lieutenants <span
class="math inline">\(L_1, ... L_{n-1}\)</span> must agree of a action
plan. Then, we have two situations:</p>
<ul>
<li><em><span class="math inline">\(IC_1\)</span></em>: all loyal
lieutenants obey the order of the commanding general;</li>
<li><em><span class="math inline">\(IC_2\)</span></em>: the decision of
loyal lieutenants must be the same as the decision of the commanding
general, if they’re loyal.</li>
</ul>
<p>In simple terms, the Interactive consistency ensures that all loyal
lieutenants follow the same command issued by the general, maintaining
consistency in the decision.</p>
<h4 id="case-study-3-generals-and-1-lieutenant-traitor">Case study: 3
generals and 1 lieutenant traitor</h4>
<p>FIrst of all, note that <strong>there are no solutions</strong> for
this case. Let’s now observe the scheme of the generals:</p>
<figure>
<img src="../images/03/byzantine1.png" width="400"
alt="Byzantine Generals" />
<figcaption aria-hidden="true">Byzantine Generals</figcaption>
</figure>
<p>In this situation, whit two different commands, we assume that <span
class="math inline">\(L_1\)</span> must obey the command of <span
class="math inline">\(C\)</span>:</p>
<ul>
<li>if <span class="math inline">\(L_1\)</span> decides to attack, both
<span class="math inline">\(IC_1\)</span> and <span
class="math inline">\(IC_2\)</span> are satisfied;</li>
<li>if <span class="math inline">\(L_1\)</span> decides to retreat,
<span class="math inline">\(IC_1\)</span> is satisfied, but <span
class="math inline">\(IC_2\)</span> is not.</li>
</ul>
<p>From the latter, we can get the following rule: <strong>if <span
class="math inline">\(L_i\)</span> receives different commands, they
will always takes the decision received by <span
class="math inline">\(C\)</span></strong>.</p>
<h4 id="case-study-3-generals-and-1-general-traitor">Case study: 3
generals and 1 general traitor</h4>
<p>The situation is the same as the previous one, and the same inferred
rule is applied:</p>
<figure>
<img src="../images/03/byzantine2.png" width="400"
alt="Byzantine Generals" />
<figcaption aria-hidden="true">Byzantine Generals</figcaption>
</figure>
<ul>
<li><span class="math inline">\(L_1\)</span> must obey to <span
class="math inline">\(G\)</span>, and decides to attack;</li>
<li><span class="math inline">\(L_2\)</span> must obey to <span
class="math inline">\(G\)</span>, and decides to retreat.</li>
</ul>
<p>In this case, the <span class="math inline">\(IC_1\)</span> is
violated, because the lieutenants have different decisions, but the
<span class="math inline">\(IC_2\)</span> is satisfied. In general,
<strong>four generals are required to cope with one
traitor</strong>.</p>
<h4 id="generalization-of-the-byzantine-generals-problem">Generalization
of the Byzantine Generals problem</h4>
<p>A general scheme for the Byzantine Problem is the following:</p>
<figure>
<img src="../images/03/byzantine3.png" width="400"
alt="Byzantine Generals" />
<figcaption aria-hidden="true">Byzantine Generals</figcaption>
</figure>
<p>In case there isn’t any traitor, each <span
class="math inline">\(L_i\)</span> will receives three copies of the
same order they’ve already received from <span
class="math inline">\(C\)</span>.</p>
<h3 id="oral-message-algorithm">Oral message algorithm</h3>
<p>In this section, we’ll go through the oral message algorithm, that is
a solution to the consensus problem. The algorithm is based on the
following assumptions:</p>
<ul>
<li>the system is <strong>synchronous</strong>;</li>
<li>any two processes can communicate with each other, and the
<strong>communication is reliable and instantaneous</strong>;</li>
<li>the <strong>receiver</strong> can identify the
<strong>sender</strong> of the message;</li>
<li>every message sent by a non-faulty process is <strong>eventually
delivered</strong>;</li>
<li>the <strong>absence of messages</strong> can be detected.</li>
</ul>
<p>This algorithm is able to solves the Byzantine problem for <span
class="math inline">\(n \ge (3m+1)\)</span> general, and includes a
majority vote on the values received from the lieutenants: note that, if
a traitor doesn’t send any message, we assume that the message is
<em>retreat</em>; consider also the fact that the majority vote returns
<em>retreat</em> if a majority is not reached.</p>
<h4 id="the-algorithm-for-om0">The algorithm for <span
class="math inline">\(OM(0)\)</span></h4>
<ol type="1">
<li>The commander C sends their value to every lieutenant <span
class="math inline">\(L_i\)</span>, with <span class="math inline">\(i
\in \{1, ..., n-1\}\)</span>;</li>
<li>Each lieutenant eses the received value.</li>
</ol>
<h4 id="the-algorithm-for-omm-with-m0">The algorithm for <span
class="math inline">\(OM(m)\)</span>, with <span
class="math inline">\(m&gt;0\)</span></h4>
<ol type="1">
<li><span class="math inline">\(C\)</span> sends their value to every
lieutenant <span class="math inline">\(L_i\)</span>, with <span
class="math inline">\(i \in \{1, ..., n-1\}\)</span>;</li>
<li>Let <span class="math inline">\(v_i\)</span> the value received by
<span class="math inline">\(L_i\)</span> from <span
class="math inline">\(C\)</span>: <span
class="math inline">\(L_i\)</span> acts as <span
class="math inline">\(C\)</span> in <span
class="math inline">\(OM(m-1)\)</span> to send <span
class="math inline">\(V_i\)</span> to each of the <span
class="math inline">\(n-2\)</span> lieutenants;</li>
<li>For each <span class="math inline">\(i\)</span>, with <span
class="math inline">\(j \ne i\)</span>, let <span
class="math inline">\(v_j\)</span> be the value that goes from <span
class="math inline">\(L_j\)</span> to <span
class="math inline">\(L_i\)</span> in the previous step;</li>
<li>Perform a majority vote among values <span
class="math inline">\(\{v_1, ..., v_{n-1}\}\)</span></li>
</ol>
<p>The algorithm is <strong>recursive</strong>, and it invokes <span
class="math inline">\(n-1\)</span> calls for <span
class="math inline">\(OM(m-1)\)</span>, <span
class="math inline">\(n-2\)</span> calls for <span
class="math inline">\(OM(m-2)\)</span> and so on.</p>
<h3 id="consideration-about-the-algorithm">Consideration about the
algorithm</h3>
<p>Solution for consensus problem are highly costly, requiring a minimum
of <span class="math inline">\(3m+1\)</span> nodes and <span
class="math inline">\(m+1\)</span> rounds, with message sizes <span
class="math inline">\(O(n^{m+1})\)</span> growing at each round.
Different metrics are used to evaluate algorithms, including the number
of faulty processors, the number of rounds, and the message size; some
of these algorithms have been proven optimal for specific aspects.</p>
<h3 id="signed-messages">Signed messages</h3>
<p>The problem is made challenging due to the ability of the traitors to
lie: in order to address this aspect, a solution involving signed
messages has been proposed, enabling generals to send unforgeable and
authenticated messages. This is a huge simplification of the problem,
that relies on the following assumptions:</p>
<ul>
<li>the <strong>signature cannot be forged</strong>, and any alteration
of a signed message can be detected;</li>
<li>the authenticity verification can be made by everyone.</li>
</ul>
<p>However, no assumptions on the signature of traitor generals have
been made.</p>
<h4 id="the-choice-algorithm">The choice algorithm</h4>
<p>Let <span class="math inline">\(V\)</span> be a set of orders, with a
function <code>choice(V)</code> that obtain a single order from a set.
The function will returns:</p>
<ul>
<li><em>retreat</em> if <span class="math inline">\(V\)</span> is
empty;</li>
<li><span class="math inline">\(v\)</span> if <span
class="math inline">\(V\)</span> is composed only by a single element
<span class="math inline">\(v\)</span>;</li>
<li><em>retreat</em> if <span class="math inline">\(V\)</span> consists
of more than one element.</li>
</ul>
<p>General <span class="math inline">\(0\)</span> is the commander, and
for each <span class="math inline">\(i\)</span>, <span
class="math inline">\(V_i\)</span> is the set of properly signed orders
that Lieutenants <span class="math inline">\(L_i\)</span> received so
far.</p>
<h4 id="signed-algorithm-smm">Signed algorithm <span
class="math inline">\(SM(m)\)</span></h4>
<p>The algorithm ensures that at most <span
class="math inline">\(m\)</span> lieutenants can send an order to their
subordinates. The algorithm is based on the following steps:</p>
<ol type="1">
<li>at the start, all lieutenants have an empty set <span
class="math inline">\(V_i\)</span>;</li>
<li><span class="math inline">\(C\)</span> signs and sends their value
to every lieutenant <span class="math inline">\(L_i\)</span>, except for
the last one;</li>
<li>each <span class="math inline">\(L_i\)</span> collects and verifies
the received signed messages, appending their signatures if necessary,
and broadcast the updated message to other lieutenants;</li>
<li>when no more messages are received, each lieutenant applies the
<code>choice</code> function to the set of received messages.</li>
</ol>
<p>Some key observations about the algorithm:</p>
<ul>
<li>lieutenants will discard any messages that have been already
received;</li>
<li>if <span class="math inline">\(L_I\)</span> is the <span
class="math inline">\(m\)</span>-th lieutenant that adds their signature
to the message, the message is not broadcasted anymore;</li>
<li>time-outs techniques can be used to detect the absence of
messages.</li>
</ul>
<p>There is an algorithm, that has been formally proved, that states:
<strong>for any <span class="math inline">\(m\)</span>, the algorithm
<span class="math inline">\(SM(m)\)</span> solves the Byzantine Generals
problem for <span class="math inline">\(n \ge 2m+1\)</span> generals and
m traitors</strong>.</p>
<h3 id="impossibility-results">Impossibility results</h3>
<p>In <strong>asynchronous distributed systems</strong>, where no timing
assumptions are made, making them easier to port application and handle
variable workloads, the consensus problem <strong>cannot be
deterministically solved</strong>, and this because it’s difficult to
distinguish between a slow process and a failed one, and deciding to
stop a single process in a inopportune moment can lead to a failure of
the consensus algorithm. In order to circumvent this issue, different
strategies can be used, such as:</p>
<ul>
<li><strong>loosely synchronized systems</strong>, where different
processors allocated to a task are executing the same iteration, so they
don’t need tight synchronization;</li>
<li><strong>median clock algorithm</strong>; each clock observes every
other clocks, and sets its time to the median value of the observed
clocks.</li>
</ul>
<h3 id="clock-synchronization">CLock synchronization</h3>
<p>Let’s observe the following figure:</p>
<figure>
<img src="../images/03/clocksyn.png" width="400"
alt="Clock synchronization" />
<figcaption aria-hidden="true">Clock synchronization</figcaption>
</figure>
<p>Without loss of generality, we can state that clock(<span
class="math inline">\(A\)</span>) $ &lt; $ clock(<span
class="math inline">\(B\)</span>) $, and assume <span
class="math inline">\(C\)</span> as faulty. Assume that <span
class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span> observe the same value of C: we have a
<strong>non Byzantine failure</strong>, with processes that may obtain
different values from the faulty process.</p>
<p>Another case can be shown with the following hypothesis:</p>
<ul>
<li>clock(<span class="math inline">\(A\)</span>) $= 10 &lt; $
clock(<span class="math inline">\(B\)</span>) $ = 20$;</li>
<li>assume a Byzantine failure of <span
class="math inline">\(C\)</span>.</li>
</ul>
<p>If <span class="math inline">\(A\)</span> sees a values for clock
<span class="math inline">\(C\)</span> that is slightly lower than its
own value, and <span class="math inline">\(B\)</span> sees a value for
clock <span class="math inline">\(C\)</span> that is slightly higher
than its own value, both <span class="math inline">\(A\)</span> and
<span class="math inline">\(B\)</span> will see their own value as the
median value, and the algorithm will fail, and this because <strong>the
median computed by two different processes will be the same if the set
of clock values they obtain is the same</strong>.</p>
<h1 id="dependability-evaluation">Dependability Evaluation</h1>
<h2 id="introduction-1">Introduction</h2>
<p>As we stated in the previous chapters, faults cause errors and
failures in the systems. however, these faults aren’t unpredictable:
their occurrences can be modeled trough the use of probability theory.
Parameters such as the Mean Time To Failure (MTTF) and the Mean Time To
Repair (MTTR) are, in fact, <strong>random variables</strong> that can
be modeled through probability distributions.</p>
<h3 id="definitions">Definitions</h3>
<ul>
<li><strong>Reliability <span
class="math inline">\(R(t)\)</span></strong> is a function of time, and
it’s the conditional probability that the system performs correctly
trough the time interval <span class="math inline">\([0,t]\)</span>,
given that the system was performing correctly at the the instant <span
class="math inline">\(t_0\)</span>. From the definitions, we can state
that <span class="math inline">\(R(0) = 1\)</span> and <span
class="math inline">\(R(\infty) = 0\)</span>;</li>
<li><strong>Unreliability <span
class="math inline">\(Q(t)\)</span></strong>, define as <span
class="math inline">\(Q(t) = 1 - R(t)\)</span>;</li>
<li><strong>Availability <span
class="math inline">\(A(t)\)</span></strong> is a time function which
represents the probability that the system is operating correctly and
it’s available to perform its functions at time <span
class="math inline">\(t\)</span>.</li>
<li><strong>failure density function <span
class="math inline">\(f(t)\)</span></strong> represents the number of
failures occurred in <span class="math inline">\(\Delta t\)</span>. From
a mathematical point of view, it’s defined as <span
class="math inline">\(f(t) = \frac{dQ(t)}{dt}=
\frac{-dR(t)}{dt}\)</span>;</li>
<li><strong>failure rate function <span
class="math inline">\(\lambda(t)\)</span></strong>, defined by the
number of failures during <span class="math inline">\(\Delta t\)</span>
in relation to the number of correct components at time <span
class="math inline">\(t\)</span>, and we can write its equations in this
way: <span class="math inline">\(\lambda(t) = \frac{f(t)}{R(t)} =
-\frac{dR(t)}{dt}\cdot\frac{1}{R(t)}\)</span></li>
</ul>
<h3 id="hardware-reliability">Hardware reliability</h3>
<p>The hardware reliability is usually described using the
<strong>failure rate distribution</strong>, that follows different
behaviors depending on the lifetime of the components. An average
behavior is the <strong>bathtub curve</strong>, which is divided into
three phases:</p>
<figure>
<img src="../images/04/bathub.png" width="400" alt="Bathtub curve" />
<figcaption aria-hidden="true">Bathtub curve</figcaption>
</figure>
<p>The <strong>early life phase</strong> is characterized by a high
failure rate, due to the presence of <strong>infant mortality</strong>,
caused by failures of weaker components (e.g. due to manufacturing
defects). The <strong>useful life phase</strong> is characterized by a
constant failure rate, which is the most common behavior of the
components, and the failure rate is described as <strong>failure every
<span class="math inline">\(x\)</span> hours</strong> (e.g. <span
class="math inline">\(\lambda = \frac{1}{2000}\)</span>, which means a
failure every 2000 hours). The <strong>wear-out phase</strong> is
characterized by an increasing failure rate, due to the aging of the
components and their usage.</p>
<p>Knowing that the failure rate is constant, we can easily get the
reliability function:</p>
<p><span class="math display">\[\lambda(t) =  \lambda =
\frac{f(t)}{R(t)}=-\frac{dR(t)}{dt}\cdot\frac{1}{R(t)} \rightarrow R(t)
= e^{-\lambda t}\]</span></p>
<p>We can also recover the equation for the probability function:</p>
<p><span class="math display">\[f(t) = \frac{dQ(t)}{dt} =
\frac{-dR(t)}{dt} = \lambda e^{-\lambda t}\]</span></p>
<blockquote>
<p>The exponential relation between reliability and time is known as
<strong>exponential failure law</strong>.</p>
</blockquote>
<h3 id="time-to-failure-of-a-component">Time-to-failure of a
component</h3>
<p>The time-to-failure of a component is a random variable that can be
modeled using a <strong>random variable <span
class="math inline">\(X\)</span></strong>, defining:</p>
<ul>
<li><span class="math inline">\(F_X(t) = P(X \leq t)\)</span> as the
<strong>cumulative distribution function</strong> (CDF) of the random
variable <span class="math inline">\(X\)</span>, that represents the
<strong>unreliability</strong> of the component;</li>
<li><strong>reliability function</strong>, defined as <span
class="math inline">\(R_X(t) = 1 - F_X(t) = P(X &gt; t)\)</span>, and it
represents the <strong>probability to not observe failures before time
<span class="math inline">\(t\)</span></strong>.</li>
<li>the <strong>mean time to failure</strong> (MTTF) is defined as <span
class="math inline">\(E[X] = \int_0^\infty tf(t)dt = \int_0^\infty
t\lambda e^{-\lambda t}dt = \frac{1}{\lambda}\)</span>.</li>
</ul>
<p>Taking as example a constant failure rate <span
class="math inline">\(\lambda = \frac{1}{2000}\)</span>, the MTTF is
<span class="math inline">\(2000\)</span> hours: speaking in terms of
probability, <span class="math inline">\(\lambda\)</span> means that
we’ll have <span class="math inline">\(0.0005\)</span> failures per
hour, and the MTTF shows that the time needed for the first failure is
<span class="math inline">\(2000\)</span> hours. A well-known unity is
the <strong>FIT</strong> (Failure In Time), which is the number of
failures in <span class="math inline">\(10^9\)</span> hours. All these
data are usually available on handbooks and datasheets of the
components.</p>
<h3 id="distribution-model-for-permanent-faults">Distribution model for
permanent faults</h3>
<p>The <strong>MIL-HDBK-217</strong> is a standard that provides a model
for the reliability of electronic components, and it’s based on the
<strong>exponential failure law</strong>. The model is based on the
<strong>constant failure rate</strong> <span
class="math inline">\(\lambda\)</span>, and it’s defined as:</p>
<p><span class="math display">\[\lambda = \tau_L\cdot \tau_Q\cdot
(C_1\cdot \tau_V\cdot \tau_T + C_2\cdot \tau_E)\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(\tau_L\)</span> is the <strong>learning
factor</strong>, based on the experience of the manufacturer;</li>
<li><span class="math inline">\(\tau_Q\)</span> is the <strong>quality
factor</strong>, based on the quality of the components;</li>
<li><span class="math inline">\(\tau_V\)</span> is the <strong>voltage
factor</strong>, based on the voltage applied to the component;</li>
<li><span class="math inline">\(\tau_T\)</span> is the
<strong>temperature factor</strong>, based on the temperature of the
ambient in which the component is placed, and the type of
semiconductor;</li>
<li><span class="math inline">\(\tau_E\)</span> is the
<strong>environment factor</strong>, based on the environment in which
the component is placed;</li>
<li><span class="math inline">\(C_1\)</span> and <span
class="math inline">\(C_2\)</span> are <strong>complexity
factors</strong>, based on number of components and the complexity of
the circuit.</li>
</ul>
<p><span class="math display">\[\qquad\]</span></p>
<h2 id="model-based-dependability-evaluation">Model-based dependability
evaluation</h2>
<p>A model is an <strong>abstraction</strong> of a real system, that
highlights the most important aspects of the system that are going to be
analyzed. Two main types of models are used in dependability
evaluation:</p>
<ul>
<li><strong>Stochastic models</strong>, that are based on probability
theory and are used to model the behavior of the system in terms of
<strong>random variables</strong>, such as Reliability Block Diagrams
(RBDs) and Fault Trees (FTs);</li>
<li><strong>State-space models</strong>, that are based on the state of
the system and are used to model the behavior of the system in terms of
<strong>states</strong>, such as Markov Chains and Petri Nets.</li>
</ul>
<p>In this chapter, we’ll present the both types of models.</p>
<h2 id="combinatorial-stochastic-models">Combinatorial (stochastic)
models</h2>
<p>These models offer simple and intuitive methods for the construction
of the system model, and for their solution. It’s fundamental to keep in
mind some assumptions that will be used in the following sections:</p>
<ul>
<li><strong>Components are independent</strong>: the failure of a
component doesn’t affect the failure of the others;</li>
<li>each component has a <strong>constant failure rate</strong> <span
class="math inline">\(\lambda\)</span>;</li>
<li>the system model is based on the actual structure of the
system;</li>
</ul>
<p>It’s also importa to remember that these models aren’t ideal when
dealing with systems that shows complex dependencies among components,
and for systems that are repairable.</p>
<h3 id="series-models">Series models</h3>
<p>A simple schema for these systems is the following:</p>
<figure>
<img src="../images/04/serie.png" width="400" alt="Series model" />
<figcaption aria-hidden="true">Series model</figcaption>
</figure>
<p>The system is composed by <span class="math inline">\(n\)</span>
components, and the system is working if all the components are working.
The reliability of the system is the product of the reliability of the
components.</p>
<p>Given <span class="math inline">\(R_i(t)\)</span> the reliability of
the <span class="math inline">\(i\)</span>-th component, the reliability
of the system is:</p>
<p><span class="math display">\[R(t) = R_1(t)\cdot R_2(t)\cdot \ldots
\cdot R_n(t) = \prod_{i=1}^n R_i(t)\]</span></p>
<p>If every component has a constant failure rate <span
class="math inline">\(\lambda\)</span>, the reliability of the system
is:</p>
<p><span class="math display">\[R(t) = e^{-\lambda_1 t}\cdot
e^{-\lambda_2 t}\cdot \ldots \cdot e^{-\lambda_n t} = e^{-(\lambda_1 +
\lambda_2 + \ldots + \lambda_n)t} = e^{-\sum_{i=1}^n \lambda_i
t}\]</span></p>
<p>The unreliability of the system is:</p>
<p><span class="math display">\[Q(t) = 1 - R(t) = 1 - \prod_{i=1}^n
R_i(t) = 1 - \prod_{i=1}^n (1 - Q_i(t))\]</span></p>
<p>If the system doesn’t contain any redundancy, and the components are
independent, then:</p>
<ul>
<li>the <strong>system reliability</strong> is the product of the
<strong>component reliabilities</strong>, and it’s an
<strong>exponential function</strong>;</li>
<li>the <strong>failure rate <span
class="math inline">\(\lambda\)</span></strong> of the system is the sum
of the <strong>failure rates <span
class="math inline">\(\lambda_i\)</span></strong> of the
components.</li>
</ul>
<h3 id="parallel-models">Parallel models</h3>
<p>A simple schema for these systems is the following:</p>
<figure>
<img src="../images/04/parallel.png" width="400" alt="Parallel model" />
<figcaption aria-hidden="true">Parallel model</figcaption>
</figure>
<p>The system is composed by <span class="math inline">\(n\)</span>
components, and the system is working if at least one of the components
is working.</p>
<p>The unreliability of the system is <span class="math inline">\(Q(t) =
\prod_{i=1}^n Q_i(t)\)</span>, and the reliability of the system is
<span class="math inline">\(R(t) = 1 - Q(t) = 1 - \prod_{i=1}^n Q_i(t) =
1 - \prod_{i=1}^n (1 - R_i(t))\)</span>.</p>
<p>We can generalize this system to a <strong>M-of-N</strong> system, in
which the system is working if at least <span
class="math inline">\(M\)</span> components are working. The reliability
of these systems is:</p>
<p><span class="math display">\[R(t) = \sum_{i=M}^N \binom{N}{i}
R_i(t)^{N-1} (1 - R_i(t))^{i}\]</span></p>
<p>If the system has redundancy, and if components are independent, then
the <strong>system reliability</strong> is the
<strong>reliability</strong> of a series/parallel combinatorial
model.</p>
<h3 id="example-tmr-vs-simplex-system">Example: TMR vs Simplex
system</h3>
<p>Take as example a simple system with only one component <span
class="math inline">\(s\)</span>, and a TMR system with three
components.</p>
<p>The component <span class="math inline">\(s\)</span> has a failure
rate <span class="math inline">\(\lambda\)</span>, with <span
class="math inline">\(R_s = e^{-\lambda t}\)</span> which us also the
reliability of the system.</p>
<p>In the TMR system, we assume the reliability of the voter <span
class="math inline">\(R_v(t) = 1\)</span>, and the reliability of the
TMR is</p>
<p><span class="math display">\[R_{TMR} = \sum_{i=0}^1
\binom{3}{i}(e^{-\lambda t})^{3-i}(1-e^{-\lambda t})^i = (e^{-\lambda
t})^3 + 3(e^{-\lambda t})^2(1-e^{-\lambda t})\]</span></p>
<p>So it’s clear that the TMR system is more reliable than the simplex
system, if <span class="math inline">\(R_m &gt; 0.5\)</span>.</p>
<p>The behavior of the reliability of these two systems is shown in the
following graph:</p>
<figure>
<img src="../images/04/graph1.png" width="400"
alt="TMR vs Simplex - Taken from Siewiorek et al. 1998" />
<figcaption aria-hidden="true">TMR vs Simplex - Taken from Siewiorek et
al. 1998</figcaption>
</figure>
<p>Focusing on the MTTF, we can get with ease that, for the simplex
system, the MTTF is <span
class="math inline">\(\frac{1}{\lambda}\)</span>, while for the TMR
system is <span class="math inline">\(\frac{3}{2\lambda} -
\frac{2}{3\lambda} = \frac{5}{6\lambda}\)</span>, which is lower than
the MTTF of the simplex system.</p>
<p>In conclusion, we can state that:</p>
<ul>
<li>the <strong>TMR system</strong> is worst than the <strong>simplex
system</strong> in terms of <strong>MTTF</strong>;</li>
<li>the <strong>TMR system</strong> is better than the <strong>simplex
system</strong> in terms of <strong>reliability</strong>, for the first
6000 hours;</li>
<li>the <strong>TMR system</strong> with a reliability above <span
class="math inline">\(0.8\)</span> lasts <span
class="math inline">\(66%\)</span> longer than the <strong>simplex
system</strong>.</li>
</ul>
<figure>
<img src="../images/04/graph2.png" width="400"
alt="TMR vs Simplex - Taken from Siewiorek et al. 1998" />
<figcaption aria-hidden="true">TMR vs Simplex - Taken from Siewiorek et
al. 1998</figcaption>
</figure>
<p>The <em>S-shaped</em> curve is typical of the <strong>redundant
systems</strong>: above the <strong>knee point</strong>, the system is
more reliable than the simplex system, while below the <strong>knee
point</strong>, the system doesn’t get any advantage from the
redundancy.</p>
<h3 id="non-seriesparallel-systems">Non-series/parallel systems</h3>
<p>Have a look at the following system:</p>
<figure>
<img src="../images/04/mixed.png" width="400"
alt="Non-series/parallel system - Taken from Siewiork et al. 1992" />
<figcaption aria-hidden="true">Non-series/parallel system - Taken from
Siewiork et al. 1992</figcaption>
</figure>
<p>The system will operate correctly if exists a path from the input to
the output that doesn’t contain any faulty component. The reliability is
computed expanding around one module <span
class="math inline">\(m\)</span>:</p>
<p><span class="math display">\[R_{sys} = R_B \cdot P(\text{system
works} | B) + (1 - R_B) \cdot P(\text{system works} |
\overline{B})\]</span></p>
<p>We can visualize this expansion trough the following figure:</p>
<figure>
<img src="../images/04/expanded.png" width="400"
alt="Non-series/parallel system - Taken from Siewiork et al. 1992" />
<figcaption aria-hidden="true">Non-series/parallel system - Taken from
Siewiork et al. 1992</figcaption>
</figure>
<p>We can also parallelize the system, reaching the following schema
where all the possible paths are in parallel:</p>
<figure>
<img src="../images/04/parallelized.png" width="400"
alt="Non-series/parallel system - Taken from Siewiork et al. 1992" />
<figcaption aria-hidden="true">Non-series/parallel system - Taken from
Siewiork et al. 1992</figcaption>
</figure>
<h4 id="upper-bound-of-the-system-reliability">Upper bound of the system
reliability</h4>
<p>Then we define the <strong>upper bound</strong> as <span
class="math inline">\(R_{sys} \leq 1 - \prod_{i=1}^n (1-R_{\text{path
i}})\)</span>; we cannot compute the exact value of the reliability of
the system, because <strong>paths are not independent</strong>, meaning
that the failure of a single module can affect the reliability of more
than one path. The upper bound of the system we took as example is <span
class="math inline">\(R_{sys} \leq 1 - (1 - R_AR_BR_CR_D)\cdot(1 -
R_AR_ER_D)\cdot(1-R_FR_CR_D)\)</span></p>
<h4 id="lower-bound-of-the-system-reliability">Lower bound of the system
reliability</h4>
<p>The <strong>lower bound</strong> is the <strong>minimal cut
set</strong> of the system, which is the list of components such that
the removal of any component from this set, will cause the system to
change its state from working to failed.</p>
<p>In the example, the minimal cut sets are <span
class="math inline">\(\{D\}, \{A,F\}, \{E,C\},\{A,C\},
\{B,E,F\}\)</span>, and the lower bound can be computed as <span
class="math inline">\(R_{sys} \geq\prod_{i=1}^n R_{\text{cut set
i}}\)</span>, which lead to <span class="math inline">\(R_{sys} \geq
(1-(1-R))\cdot(1-(1-R)^2)^3\cdot(1-(1-R)^3)\)</span></p>
<h3 id="fault-trees">Fault Trees</h3>
<p>Fault Trees are a graphical representation of the system, that shows
the possible paths that lead to the failure of the system. The system is
represented as a <strong>root node</strong>, which represents the
<strong>top event</strong> in terms of status (e.g. system failure), and
the <strong>leaves</strong> of the tree represent the <strong>basic
events</strong> that can lead to the top event. The analysis of the tree
is based on evaluating the <strong>probability of occurrence of the top
event</strong>, in terms of the <strong>probability of occurrence of the
basic events</strong>.</p>
<figure>
<img src="../images/04/faultTree.png" width="400" alt="Fault Tree" />
<figcaption aria-hidden="true">Fault Tree</figcaption>
</figure>
<h4 id="logical-gates">Logical gates</h4>
<p>The basic events are connected through <strong>logical
gates</strong>, that are used to combine the basic events in order to
get the top event. The most common gates are:</p>
<ul>
<li><strong>AND gate</strong>: the top event occurs if all the basic
events occur;</li>
<li><strong>OR gate</strong>: the top event occurs if at least one of
the basic events occurs;</li>
<li><strong>K-of-N gate</strong>: the top event occurs if at least <span
class="math inline">\(K\)</span> of the <span
class="math inline">\(N\)</span> basic events occur.</li>
</ul>
<p>Conventionally, the logical value <strong>true</strong> corresponds
to a <strong>failure</strong>, while the logical value
<strong>false</strong> corresponds to a <strong>success</strong>: the
system is working if the top event is <strong>false</strong>, otherwise
the system is failed.</p>
<h4 id="minimal-cut-sets">Minimal Cut Sets</h4>
<p>A cut is identified as a set of events such that, according to the
logic showed in the tree, leads to the top event. Let’s take as example
the following tree:</p>
<figure>
<img src="../images/04/tree.png" width="400" alt="Fault Tree example" />
<figcaption aria-hidden="true">Fault Tree example</figcaption>
</figure>
<p>The cut sets are <span class="math inline">\(\{1\}, \{2\}, \{G1\},
\{5\}\)</span>, and the minimal cut sets are <span
class="math inline">\(\{1\}, \{2\}, \{3,4\}, \{5\}\)</span>. To estimate
the probability of the root event, the probabilities of the occurrence
of every set are computed and combined.</p>
<p>For this purpose, we can define <span
class="math inline">\(Q_s(t)\)</span> as the probability that all the
components in the minimal cut set <span class="math inline">\(s\)</span>
are faulty, and it’s computed as <span class="math inline">\(Q_s(t) =
\prod_{i \in s} Q_i(t)\)</span>, having <span
class="math inline">\(Q_i(t)\)</span> the probability that the component
<span class="math inline">\(i\)</span> is faulty. The numerical solution
for the Fault Tree is performed by computing the probability of
occurrence for each cut, and then combining those probabilities, to
estimate the probability of the top event.</p>
<h4 id="multiple-appearances-of-the-same-component">Multiple appearances
of the same component</h4>
<p>In the case of multiple appearances of the same component, the
independent event assumption is violated; however, we can still compute
the probability of the top event: if a component <span
class="math inline">\(C\)</span> appears multiple times in the Fault
Tree, then:</p>
<p><span class="math display">\[Q_s(t) = Q_{s|C \text{ is
faulty}}(t)\cdot Q_C(t) + Q_{s|C \text{ is working}}(t)\cdot (1 -
Q_C(t))\]</span></p>
<p>where <span class="math inline">\(Q_{s|C \text{ is
faulty}}(t)\)</span> is the system reliability when the component <span
class="math inline">\(C\)</span> is faulty, and <span
class="math inline">\(Q_{s|C \text{ is working}}(t)\)</span> is the
system reliability when the component <span
class="math inline">\(C\)</span> is working.</p>
<h4 id="fault-tree-analysis">Fault Tree analysis</h4>
<p>Use of Fault Tree involves defining the top event, which is the
undesired outcome, and then identifying the basic events that can lead
to the top event, as a cut set. The analysis of a Fault Tree includes
also the need of determining the failure probability of basic events, of
the minimal cut sets, and the single points of failures for the system,
that corresponds to a cut set with only one component.</p>
<h3 id="failure-mode-and-effect-analysis">Failure Mode and Effect
Analysis</h3>
<p>The <strong>FMEA</strong> is a failure analysis technique used to
identify the risk of a failure in a system, or a component also; it
involves analyzing the vulnerability of a system to a single failure,
and required knowledge on how these potential failures can combine with
each other, which are the consequences of these failures and possible
actions to be taken in order to prevent these failures.</p>
<p>The technique is based on the <strong>Risk Priority Number
(RPN)</strong>, which is computed considering the
<strong>severity</strong> of the failure, the
<strong>occurrence</strong> of the failure, and the
<strong>detectability</strong> of the failure.</p>
<h4 id="the-fmea-table">The FMEA table</h4>
<p>To ensure dependability, a system’s functionality must be identified,
along with its potential failures and failures modes. A table is
created: it should be created detailing each failure mode, its potential
effects on components and system, and a severity ranking from 1 to
10.</p>
<p>For each cause of failure, a list of the current process controls is
created, with details on tests, procedures, or mechanism that might
prevent the cause from happening, reducing the probability that it will
occur, or detect the failure before it causes a problem, before the
customer is affected; a <strong>rank dection rating</strong> is also
computed, from 1 to 10.</p>
<p>In the following figure, an example of an FMEA table for an ATM
system is shown:</p>
<figure>
<img src="../images/04/FMEA-table.png" width="400" alt="FMEA table" />
<figcaption aria-hidden="true">FMEA table</figcaption>
</figure>
<h4 id="the-rpn">The RPN</h4>
<p>The <strong>Risk Priority Number (RPN)</strong> is computed as the
product of the <strong>severity</strong>, <strong>occurrence</strong>,
and <strong>detection</strong> rankings, and it’s used to prioritize the
failures that need to be addressed first. The RPN is computed as <span
class="math inline">\(RPN = S \cdot O \cdot D\)</span>, and the higher
the RPN, the higher the priority of the failure.</p>
<p>In conclusion, FMEA helps ranking potential failures and identify
recommended actions, such as additional controls, to improve the
system’s detection and prevention capabilities. It enables the
association of a cause, such as a simple component failure, with its
effect on the system, and helps in identifying the most critical
failures that need to be addressed first.</p>
<h3 id="fmea-with-fault-trees">FMEA with Fault Trees</h3>
<p>The FMEA can be used in combination with Fault Trees to identify the
most critical failures that need to be addressed first: the first is
used to analyzes the vulnerability of the system due to a single
failure, while the latter describes scenarios where an event occurs due
to the combination of multiple failures.</p>
<h2 id="state-based-models">State-based models</h2>
<p>These models are used for dependability evaluation of systems that
can be described in terms of states, considering that the reliability of
these systems depends on the <strong>frequency</strong> and
<strong>duration</strong> of the faults in the system. This approach is
different from, as example, the series/parallel models, because the
state-based enumerates all the possible states of the system, and can be
employed for evaluating both reliability and availability, providing a
more detailed analysis of the system.</p>
<p>State-based models are used in dependability evaluation to
characterize the changes of the system’s state over time: each state
represents a different combination of both failed and working
components, and the transitions between states are caused by the
occurrence of faults in the system. Obviously, probabilities of failures
and repairs are key factors in the analysis of these models, in order to
characterize states and transitions over time.</p>
<h3 id="representing-the-system-state">Representing the system
state</h3>
<p>The most used graphical representation for state-based models are
<strong>graphs</strong>, where nodes represent states of the system, and
edges represent transitions between states: in particular, labels on the
edges represent the number of working and failed components in the
system, and the probabilities of transitions. Consider the following
example:</p>
<figure>
<img src="../images/04/singleComponent.png" width="400"
alt="State-based model" />
<figcaption aria-hidden="true">State-based model</figcaption>
</figure>
<p>The system is composed by a single component, and the states are
represented by the number of failed components in the system. The
transitions between states depends on <span
class="math inline">\(p_f\)</span>, which is the <strong>probability of
failure</strong>, while <span class="math inline">\(p_r\)</span> is the
<strong>probability of repair</strong>.</p>
<p>We can distinguish between <strong>reliability model</strong> and
<strong>availability model</strong>: the first is used to evaluate the
probability that the system is in a working state at time <span
class="math inline">\(t\)</span>, while the availability model is used
to evaluate the probability that the system is in a working state and is
available to perform its functions at time <span
class="math inline">\(t\)</span>.</p>
<h3 id="random-process">Random process</h3>
<p>In probability theory, a random process is a <strong>collection of
random variables</strong> indexed by time, representing the evolution of
a system over time, such as the toss of a coin. Following the same
logic, when we talk about dependability measures, we refer to variables
that represent system’s value of the state that changes randomly over
time.</p>
<p>We lastly define the <strong>state space</strong> of the system as
the set of all possible states of the system.</p>
<h3 id="markov-chains">Markov Chains</h3>
<p>A <strong>Markov Chain</strong> is a state-based model that describes
the evolution of a system over time, where the probability of the system
to be in a certain state at time <span class="math inline">\(t\)</span>
depends only on the state of the system at time <span
class="math inline">\(t-1\)</span>. This property is called is called
<strong>Markov property</strong>, and processes that satisfy this
property are called <strong>Markov processes</strong>.</p>
<h4 id="insights-on-markov-property">Insights on Markov property</h4>
<p>The equation that describes the Markov property is:</p>
<p><span class="math display">\[P(X_{t+1} = j | X_t = i, X_{t-1} =
i_{t-1}, \ldots, X_0 = i_0) = P(X_{t+1} = j | X_t = i)\]</span></p>
<p>which means that state of the process at time <span
class="math inline">\(t+1\)</span> depends only on the state of the
process at time <span class="math inline">\(t\)</span>, <strong>being
independent from all previous states</strong>. This is also the basic
assumption of the Markov Chain model.</p>
<h4 id="transition-probabilities">Transition probabilities</h4>
<p>We define <strong>transition probability</strong> as the probability
of the system to move from state <span class="math inline">\(i\)</span>
to state <span class="math inline">\(j\)</span> in one time unit, and
it’s denoted as <span class="math inline">\(p_{ij}\)</span>, and the
<strong>Steady-State transition Probability</strong> as those transition
probabilities such that, for any pair of states <span
class="math inline">\(i\)</span> and <span
class="math inline">\(j\)</span>, the probability of the system to be in
state <span class="math inline">\(j\)</span> at time <span
class="math inline">\(t+1\)</span> is the same as the probability of the
system to be in state <span class="math inline">\(j\)</span> at time
<span class="math inline">\(t\)</span>; in other words, the transition
probabilities are constant over time.</p>
<h4 id="definition-of-a-markov-chain">Definition of a Markov Chain</h4>
<p>A stochastic process is a Markov Chain if it satisfies the Markov
property, and if the transition probabilities are constant over time. A
Markov chain is called <strong>homogeneous</strong> if the transition
probabilities are constant over time, so if it satisfies the property of
steady-state transition probabilities; otherwise, it’s called
<strong>non-homogeneous</strong>.</p>
<h4 id="transition-matrix">Transition matrix</h4>
<p>A Markov chain is <strong>finite-state</strong> if the number of
states is finite; in this case transitions are representable as a
matrix, called <strong>transition matrix</strong>.</p>
<figure>
<img src="../images/04/transitionMatrix.png" width="400"
alt="Transition matrix" />
<figcaption aria-hidden="true">Transition matrix</figcaption>
</figure>
<p>Notations represent:</p>
<ul>
<li><span class="math inline">\(n\)</span> as the number of states;</li>
<li><span class="math inline">\(i\)</span> and <span
class="math inline">\(j\)</span> as the states of the system;</li>
<li><span class="math inline">\(p_{ij}\)</span> as the probability of
moving from state <span class="math inline">\(i\)</span> to state <span
class="math inline">\(j\)</span> in one time unit;</li>
</ul>
<p>The transition matrix satisfies the following property: &gt; let
<span class="math inline">\(u = [1, 1, \ldots, 1]^T\)</span> be a vector
of ones, then <span class="math inline">\(P\cdot u = u\)</span>.</p>
<p>This follows by the condition that the sum of the elements in each
row of the matrix is equal to 1, and represents the probability to
moving from a state <span class="math inline">\(i\)</span> into any
other state.</p>
<p>Non-negative matrices where the property <span
class="math inline">\(P\cdot u = u\)</span> holds are called
<strong>stochastic matrices</strong>.</p>
<p>The matrix can be associated with ease to a graph, where the nodes
represent the states of the system, and the edges represent the
transitions between states.</p>
<h4 id="theorem-for-discrete-time-markov-chains">Theorem for
Discrete-Time Markov Chains</h4>
<p>For each pair of states <span class="math inline">\(i\)</span> and
<span class="math inline">\(j\)</span>, with <span
class="math inline">\(n\geq 0\)</span>, then <span
class="math inline">\(P\{X_{n+1} = j | X_n = i\} = P\{X_n = j | X_0 =
i\} \forall t \geq 0\)</span>.</p>
<p>From this theorem, we can derive every steady-state probability of
the system after <span class="math inline">\(n\)</span> transitions:</p>
<p><span class="math display">\[ p_{ij}^{(n)} = P\{X_n = j | X_0 = i\}
\]</span></p>
<p>In particular, we define:</p>
<ul>
<li><span class="math inline">\(p_{ij}^{(0)} = P\{X_0 = j | X_0 = i\} =
\delta_{ij}\)</span>, where <span
class="math inline">\(\delta_{ij}\)</span> is the <strong>Kronecker
delta</strong>;</li>
<li><span class="math inline">\(p_{ij}^{(1)} = P\{X_1 = j | X_0 = i\} =
p_{ij}\)</span>;</li>
<li><span class="math inline">\(p_{ij}^{(n)} = P\{X_n = j | X_0 =
i\}\)</span>.</li>
</ul>
<p>Following properties are also valid:</p>
<ul>
<li><span class="math inline">\(0 \leq p_{ij}^{(n)} \leq 1 \forall
i,j\)</span>;</li>
<li><span class="math inline">\(\sum_{j=1}^n p_{ij}^{(n)} = \sum_{j=1}^n
P\{X_n = j | X_0 = i\} = 1 \forall i\)</span>.</li>
</ul>
<h4 id="chapman-kolmogorov-theorem">Chapman-Kolmogorov theorem</h4>
<p>This theorem states that <strong>for each pairs of states <span
class="math inline">\(i\)</span> and <span
class="math inline">\(j\)</span>, and for each <span
class="math inline">\(n,m \geq 1\)</span>, then <span
class="math inline">\(p_{ij}^{(n+m)} = \sum_{k=1}^n
p_{ik}^{(n)}p_{kj}^{(m)}\)</span></strong>.</p>
<p>Knowing that <span class="math inline">\(P^{(0)} = I\)</span>, where
<span class="math inline">\(I\)</span> is the identity matrix, <span
class="math inline">\(P^{(1)} = P\)</span>, and <span
class="math inline">\(P^{(n)} = P^n\)</span>, we can prove that <span
class="math inline">\(P^{(n+m)} = P^n\cdot P^m\)</span>. Since <span
class="math inline">\(P^{(k)} = P^{(k-1)}\cdot P^{(1)} = P^{(k-1)}\cdot
P\)</span>, we can state that <span class="math inline">\(P^{(n)} =
P^n\)</span>, with <span class="math inline">\(P^{(n)}\)</span> being a
stochastic matrix.</p>
            </div>
    </div>
  </div>
  <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>

</body>
</html>
