<!doctype html>
<html  lang="it" >
<head>
    <style>
		#TOC {
			overflow-y: hidden !important; 
			font-size: smaller !important;
			/*margin-right: 20px;*/
		}

		p, h1, h2, h3, h4, h5, a, span, li, ul, ol, th, tr, table, figcaption {
			font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Open Sans","Helvetica Neue",sans-serif !important;
		}

		[class*="span"] {
			margin-left: 0 !important;
		}

		.well {
			min-height: 0px !important;
			padding: 0px !important;
			margin-bottom: 0px !important;
			background-color: #FFFFFF  !important;
			border: 0 !important;
			-webkit-border-radius: 0 !important;
			-moz-border-radius: 0 !important;
			border-radius: 0 !important;
			-webkit-box-shadow: none !important;
			-moz-box-shadow: none !important;
			box-shadow: none !important;
		}

		.navbar-inner {
			background-color: #fefefe !important;
			background-image: none !important;
			background-repeat: no-repeat !important;
			filter: none !important;
			border: 0 !important;
			-webkit-border-radius: 0px !important;
			-moz-border-radius: 0px !important;
			border-radius: 0px !important;
			margin-bottom: 15pt !important;

			-webkit-box-shadow: 0 1px 10px rgb(0 0 0 / 7%) !important;
			-moz-box-shadow: 0 1px 10px rgba(0,0,0,.07) 1 !important;
			box-shadow: 0 1px 10px rgb(0 0 0 / 7%) !important;
		}
		
		
		li > ul {
			padding-left: 15px !important;
		}

		pre {
			background-color: #f6f8fa !important;
			border-radius: 3px !important;
			/*font-size: 85% !important;*/
			line-height: 1.45 !important;
			overflow: auto !important;
			padding: 16px !important;
			font-family: Monaco, Menlo, Consolas, "Courier New", monospace !important;
			border: 0 !important;
		}
		
		code {
			/*background-color: rgba(27,31,35,.05) !important;*/
			border-radius: 3px !important;
			border: 0 !important;
			/*font-size: 85% !important;*/
			margin: 0 !important;
			padding: 0.2em 0.4em !important;
			font-family: Monaco, Menlo, Consolas, "Courier New", monospace !important;
		}

		table th {
			background-color: #f6f8fa !important;
		}

		
		.math * {
			font-family: Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman', serif !important;
		}

		.katex-display>.katex>.katex-html {
			font-size: 85% !important;
			font-family: Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman', serif !important;
		}

		/*distanzia*/
		h1:not(:first-of-type){
			margin-top: 50px !important;
		}

		/* fa comparire la barra del capitolo */
		h1 {
			border-bottom: 1px solid #e8e8e8fa !important;
			font-size: 2.2em !important;
		}

		/*distanzia*/
		h2 {
			margin-top: 30px !important;
			font-size: 1.6em !important;
		}

		/*distanzia*/
		h3 {
			margin-top: 20px !important;
			font-size: 1.3em !important;
		}

		h4 {
			font-size: 1em !important;
		}

		/* stile box */
		.note, .tip, .caution, .warning, .attention, .error, .danger, .definition {
			border-radius: 5pt;
			padding-left: 10px;
			padding-right: 10px;
			padding-top: 1px;
			padding-bottom: 1px;
			line-height: normal;
			color: #000000ab;
			margin: 6pt 0pt 6pt 0pt;
		}

		.note code, .tip code, .caution code, .warning code, .attention code, .error code, .danger code, .definition code, .danger code {
			background-color: #00000014;
		}

		.note {
			background-color: #88d3f9;
		}

		.tip {
			background-color: #87f0b8;
		}

		.caution, .warning, .attention {
			background-color: #ffe162;
		}

		.error, .danger {
			background-color: #ff7474;
		}

		.definition {
			background-color: #f191ff;
		}

		.table {
			border-top: 1px solid #ddd;
			margin-top: 15px;
		}


	</style>

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />

    <!-- <link rel="stylesheet" type="text/css" href="template.css" /> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/template.css" />

    <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />

    <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
    <!-- <script type='text/javascript' src='menu/js/jquery.cookie.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script> -->

    <!-- <link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" /> -->
  
    <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
        
  
    <!-- <script src="script.js"></script> -->
  
    <!-- <script src="jquery.sticky-kit.js "></script> -->
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.cookie.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.hoverIntent.minified.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/ryangrose/easy-pandoc-templates@948e28e5/css/elegant_bootstrap.css" rel="stylesheet" type="text/css" />
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/script.js"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/jquery.sticky-kit.js"></script>
    <meta name="generator" content="pandoc" />
  <meta name="author" content="Giovanni Enrico Loni" />
  <title>Formal Methods for Secure Systems</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  
</head>
<body>

    
    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">Formal Methods for Secure Systems</span>
        <ul class="nav pull-right doc-info">
                    <li><p class="navbar-text">Giovanni Enrico
Loni</p></li>
                            </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

        <ul>
        <li><a href="#introduction"
        id="toc-introduction">Introduction</a>
        <ul>
        <li><a href="#outline-of-the-course"
        id="toc-outline-of-the-course">Outline of the course</a></li>
        <li><a href="#computer-based-systems"
        id="toc-computer-based-systems">Computer-based systems</a></li>
        </ul></li>
        <li><a href="#basic-concepts-and-terminology"
        id="toc-basic-concepts-and-terminology">Basic concepts and
        terminology</a>
        <ul>
        <li><a href="#dependability"
        id="toc-dependability">Dependability</a>
        <ul>
        <li><a href="#computer-based-systems-1"
        id="toc-computer-based-systems-1">Computer-based
        systems</a></li>
        <li><a href="#faults-and-failures"
        id="toc-faults-and-failures">Faults and Failures</a></li>
        <li><a href="#achieving-dependability"
        id="toc-achieving-dependability">Achieving
        Dependability</a></li>
        </ul></li>
        <li><a href="#the-system-entity" id="toc-the-system-entity">The
        <em>system</em> entity</a>
        <ul>
        <li><a href="#systems-properties"
        id="toc-systems-properties">System’s properties</a></li>
        <li><a href="#systems-requirements"
        id="toc-systems-requirements">System’s requirements</a></li>
        </ul></li>
        <li><a href="#dependability-tree"
        id="toc-dependability-tree">Dependability tree</a>
        <ul>
        <li><a href="#threats-to-dependability"
        id="toc-threats-to-dependability">Threats to
        dependability</a></li>
        <li><a href="#dependability-attributes"
        id="toc-dependability-attributes">Dependability
        attributes</a></li>
        </ul></li>
        <li><a href="#taxonomy-of-faults"
        id="toc-taxonomy-of-faults">Taxonomy of faults</a>
        <ul>
        <li><a href="#the-system-life-cycle"
        id="toc-the-system-life-cycle">The system life cycle</a></li>
        <li><a href="#faults-classification"
        id="toc-faults-classification">Faults classification</a></li>
        </ul></li>
        <li><a href="#failures" id="toc-failures">Failures</a>
        <ul>
        <li><a href="#failure-domain" id="toc-failure-domain">Failure
        domain</a></li>
        <li><a href="#consistency-domain"
        id="toc-consistency-domain">Consistency domain</a></li>
        <li><a href="#detectability-domain"
        id="toc-detectability-domain">Detectability domain</a></li>
        <li><a href="#consequences-domain"
        id="toc-consequences-domain">Consequences domain</a></li>
        <li><a href="#criteria-to-evaluate-the-severity-of-a-failure"
        id="toc-criteria-to-evaluate-the-severity-of-a-failure">Criteria
        to evaluate the severity of a failure</a></li>
        <li><a href="#system-failures" id="toc-system-failures">System
        failures</a></li>
        <li><a href="#dependability-and-security-failures"
        id="toc-dependability-and-security-failures">Dependability and
        security failures</a></li>
        </ul></li>
        <li><a href="#errors" id="toc-errors">Errors</a></li>
        <li><a
        href="#chain-of-threats---relationship-between-faults-errors-and-failures"
        id="toc-chain-of-threats---relationship-between-faults-errors-and-failures">Chain
        of threats - Relationship between faults, errors and
        failures</a></li>
        <li><a href="#dependability-means"
        id="toc-dependability-means">Dependability means</a>
        <ul>
        <li><a href="#fault-prevention" id="toc-fault-prevention">Fault
        prevention</a></li>
        <li><a href="#fault-tolerance" id="toc-fault-tolerance">Fault
        tolerance</a></li>
        <li><a href="#fault-handling" id="toc-fault-handling">Fault
        handling</a></li>
        <li><a href="#fault-removal" id="toc-fault-removal">Fault
        removal</a></li>
        <li><a href="#fault-forecasting"
        id="toc-fault-forecasting">Fault forecasting</a></li>
        <li><a href="#error-recovery" id="toc-error-recovery">Error
        recovery</a></li>
        </ul></li>
        <li><a href="#error-detection" id="toc-error-detection">Error
        detection</a>
        <ul>
        <li><a href="#structural-approach-to-error-detection"
        id="toc-structural-approach-to-error-detection">Structural
        approach to error detection</a></li>
        <li><a href="#measurement-of-effectiveness-of-error-detection"
        id="toc-measurement-of-effectiveness-of-error-detection">Measurement
        of effectiveness of error detection</a></li>
        <li><a href="#the-exception-handling"
        id="toc-the-exception-handling">The exception handling</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#redundancy-in-fault-tolerant-computing"
        id="toc-redundancy-in-fault-tolerant-computing">Redundancy in
        Fault Tolerant Computing</a>
        <ul>
        <li><a href="#hardware-redundancy"
        id="toc-hardware-redundancy">Hardware Redundancy</a>
        <ul>
        <li><a href="#passive-fault-tolerance-techniques"
        id="toc-passive-fault-tolerance-techniques">Passive fault
        tolerance techniques</a></li>
        <li><a href="#active-fault-tolerance-techniques"
        id="toc-active-fault-tolerance-techniques">Active fault
        tolerance techniques</a></li>
        <li><a href="#hybrid-fault-tolerance-techniques"
        id="toc-hybrid-fault-tolerance-techniques">Hybrid fault
        tolerance techniques</a></li>
        <li><a href="#summary-of-the-hardware-redundancy-techniques"
        id="toc-summary-of-the-hardware-redundancy-techniques">Summary
        of the hardware redundancy techniques</a></li>
        </ul></li>
        <li><a href="#information-redundancy"
        id="toc-information-redundancy">Information Redundancy</a>
        <ul>
        <li><a href="#parity-codes" id="toc-parity-codes">Parity
        codes</a></li>
        <li><a href="#complemented-duplication"
        id="toc-complemented-duplication">Complemented
        duplication</a></li>
        <li><a href="#hamming-distance"
        id="toc-hamming-distance">Hamming distance</a></li>
        <li><a href="#checksums" id="toc-checksums">Checksums</a></li>
        <li><a href="#ecc" id="toc-ecc">ECC</a></li>
        <li><a href="#hamming-codes" id="toc-hamming-codes">Hamming
        codes</a></li>
        <li><a href="#self-checking-circuitry"
        id="toc-self-checking-circuitry">Self-checking
        circuitry</a></li>
        </ul></li>
        <li><a href="#time-redundancy" id="toc-time-redundancy">Time
        Redundancy</a>
        <ul>
        <li><a href="#repetition-of-the-computation"
        id="toc-repetition-of-the-computation">Repetition of the
        computation</a></li>
        </ul></li>
        <li><a href="#software-redundancy"
        id="toc-software-redundancy">Software Redundancy</a>
        <ul>
        <li><a href="#software-diversity"
        id="toc-software-diversity">Software diversity</a></li>
        <li><a href="#n-version-programming"
        id="toc-n-version-programming">N-version programming</a></li>
        <li><a href="#design-diversity" id="toc-design-diversity">Design
        diversity</a></li>
        </ul></li>
        </ul></li>
        <li><a
        href="#basic-building-blocks-in-fault-tolerant-distributed-systems"
        id="toc-basic-building-blocks-in-fault-tolerant-distributed-systems">Basic
        building blocks in Fault tolerant distributed systems</a>
        <ul>
        <li><a href="#atomic-actions" id="toc-atomic-actions">Atomic
        actions</a>
        <ul>
        <li><a href="#atomic-actions-in-a-database"
        id="toc-atomic-actions-in-a-database">Atomic actions in a
        database</a></li>
        <li><a href="#atomic-actions-in-a-distributed-system"
        id="toc-atomic-actions-in-a-distributed-system">Atomic actions
        in a distributed system</a></li>
        <li><a href="#two-phase-commit"
        id="toc-two-phase-commit">Two-phase commit</a></li>
        <li><a href="#three-phase-commit"
        id="toc-three-phase-commit">Three-phase commit</a></li>
        <li><a href="#recovery-and-atomicity"
        id="toc-recovery-and-atomicity">Recovery and atomicity</a></li>
        <li><a href="#log-file" id="toc-log-file">Log file</a></li>
        </ul></li>
        <li><a href="#consensus-problem"
        id="toc-consensus-problem">Consensus problem</a></li>
        </ul></li>
        </ul>

        </div>
      </div>
            <div class="span9">

      
      <h1 id="introduction">Introduction</h1>
<h2 id="outline-of-the-course">Outline of the course</h2>
<ol type="1">
<li>Dependability
<ul>
<li>Building high reliable computer-based systems</li>
<li>Quantitative evaluation of dependability</li>
<li>Threat modeling and risk assessment</li>
<li>Malware analysis</li>
<li>Cybersecurity engineering</li>
</ul></li>
<li>Formal methods for security
<ul>
<li>Formal methods applied to security</li>
<li>Case studies: Data confidentiality, Security protocols,
Cyber-physical systems security</li>
</ul></li>
</ol>
<h2 id="computer-based-systems">Computer-based systems</h2>
<p>Computer-based systems are everywhere, and the services they offer
are very diverses. From that, we can easy understand why the
<strong>dependability</strong>, which is the ability of the system to
deliver the expected service, is a critical aspect of these systems, in
particular in a security point of view.</p>
<p>A system should (or must) be able to deliver the expected service,
even in the presence of faults, errors, and <strong>attacks</strong>.
This is the main goal of dependability, which is as important as the
functionality of the system, pheraps even more. TO achieve that, we have
<strong>Formal Methods</strong> that provide to us a set of techniques
and tools to design, verify, and validate computer-based systems, in a
rigorous and systematic way, even in presence of faults and attacks.</p>
<h1 id="basic-concepts-and-terminology">Basic concepts and
terminology</h1>
<p>All the concept and the terminology that will be presented in this
section derives directly from the paper “Basic Concepts and Taxonomy of
Dependable and Secure Computing” by Avizienis et al. (2004). This paper
is a fundamental reference in the field of dependability and security
and it is the basis for the definition of the concepts and terminology
that will be used in the entire course, as suggested by the
professor.</p>
<h2 id="dependability">Dependability</h2>
<p>We can give to <strong>dependability</strong> a simple definition:
given a system, which is designed to provide a certain service, the
dependability is the ability of that system to deliver the specified
service also in presence of faults and malfunctions. In other words
<em>dependability is that property of a computer-based system such that
reliance can justifiably be placed on the service it delivers</em>. Note
that the latter definition stresses the need for a justified reliance on
the service, which is a key aspect of dependability.</p>
<h3 id="computer-based-systems-1">Computer-based systems</h3>
<p>A computer-based system is a system that includes a certain number of
components: each of them can be interconnected and have its own
functionality. The components can be hardware, software, humans and the
environment in which the system operates.</p>
<figure>
<img src="../images/01/computer%20sysmet.png" width="500"
alt="Computer-based system - C. Bernardeschi" />
<figcaption aria-hidden="true">Computer-based system - C.
Bernardeschi</figcaption>
</figure>
<h3 id="faults-and-failures">Faults and Failures</h3>
<p>We call a <strong>failure</strong> the inability of the system to
deliver the expected service, and a <strong>fault</strong> the cause of
that failure.</p>
<p><strong>Example:</strong> if a cash machine delivers the wrong amount
of money, we can say that the system has failed.</p>
<p>A fault causes an <strong>error</strong> in the state of the system,
which lead to a <strong>failure</strong>. A failure can have different
nature, such as physical, logical, human error or even as consequence of
an attack.</p>
<p><strong>Example: Logic Bomb.</strong> It’s a piece of code that is
inserted into a software system that will execute a malicious function
when specified conditions are met.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>legitimate_code<span class="op">();</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>date <span class="op">==</span> <span class="st">&quot;01/01/2020&quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    crash_system<span class="op">();</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>legitimate_code<span class="op">();</span></span></code></pre></div>
<p>Computer Faults vs. Other Equipment Faults Computer faults differ
from those of other equipment in several ways:</p>
<ul>
<li><strong>Subtler Failures</strong>: computer failures are more subtle
than outright crashes or sudden stops.</li>
<li><strong>Information Storage</strong>: computers store information in
various ways, leading to a multitude of possible errors, both internally
and externally.</li>
<li><strong>Hidden Small Defects, Big Effects</strong>: even small
hidden defects can have significant impacts, especially in digital
systems.</li>
<li><strong>Complex Hierarchies</strong>: computer systems are intricate
hierarchies built upon hidden components.</li>
</ul>
<h3 id="achieving-dependability">Achieving Dependability</h3>
<p>The dependability of a system can be achieved going trough a rigorous
and engineered steps. Two main figures are involved, system and software
engineers:</p>
<ul>
<li><strong>System engineers</strong> are responsible for the design of
the system, and they have to use analysis to model the dependability of
the their design. From these, the software specifications are derived,
and the possible changes to the system are evaluated, in order to
accomodate software limitations;</li>
<li><strong>Software engineers</strong> are responsible for the
implementation of the software, and they have to use the specifications
to develop the software, and to test it in order to verify that it meets
the requirements.</li>
</ul>
<p>In general, it’s crucial to understand that <strong>dependability is
not something that can be added to a system as an afterthought</strong>.
It must be considered from the very beginning of the design process, and
it must be an integral part of the system, wusing a scientific and
engineering approach.</p>
<h2 id="the-system-entity">The <em>system</em> entity</h2>
<p>A simple but effective definition of a system is the following: a
system is a entity that interacts with the environment and other
systems; its boundaries are the common frontier between the system and
the environment.</p>
<h3 id="systems-properties">System’s properties</h3>
<p>A system has a <strong>function</strong>, which is the service that
it provides to the environment, and it’s described by its own functional
specification. It also has a <strong>behavior</strong>, visualized as
the sequence of states that the system goes through during its
operation, and it’s how the system implements its function. Then there
is the <strong>structure</strong>, which is the way the system is
organized, and it’s described by its own structural specification.</p>
<p>From the user point of view, the system has a <strong>delivered
service</strong>, which is the result of the interaction between the
user and the system, that is the behavior of the system as perceived by
the user. Obviously, the user can be seen as another system that
interacts with the system under consideration.</p>
<h3 id="systems-requirements">System’s requirements</h3>
<p>First of all, we need to define the problem that the system has to
solve, and then we have to define the requirements that the system has
to meet, and then we have to define both functional and dependability
requirements. Pay attention to the difference between the system’s
function and the system’s specification: the former is the service that
the system provides, while the latter is the solution implemented to
provide that service. In the end, we define the
<strong>correctness</strong> of the system, which is the ability of the
system to deliver the specified service.</p>
<h2 id="dependability-tree">Dependability tree</h2>
<p>Take in consideration the following dependability tree:</p>
<figure>
<img src="../images/01/dependability%20tree.png" width="500"
alt="Dependability tree - Avizienis et al., 2004" />
<figcaption aria-hidden="true">Dependability tree - Avizienis et al.,
2004</figcaption>
</figure>
<h3 id="threats-to-dependability">Threats to dependability</h3>
<p>As we said before, a <strong>correct service</strong> is delivered if
the service is delivered in accordance with the system’s specification.
When this doesn’t happen, we have a <strong>service failure</strong>,
which is one the possible states of the system:</p>
<figure>
<img src="../images/01/states.png" width="500"
alt="Service failure - C. Bernardeschi" />
<figcaption aria-hidden="true">Service failure - C.
Bernardeschi</figcaption>
</figure>
<p>We call <strong>service outage</strong> the period during which the
system is not able to deliver the service, a <strong>service
degradation</strong> the period during which the system delivers a
service that is not in accordance with the specification, such as a
subset of the services. We also recall the <strong>chain of
threats</strong> to dependability: <strong>faults</strong> causes
<strong>errors</strong>, which lead to <strong>failures</strong>: note
that many errors don’t cause failures because they don’t reach the
external state of the system.</p>
<p>Faults can be <strong>dormant</strong>, that is they are present in
the system but they don’t cause errors, and <strong>active</strong>,
that is they cause errors, and thay can be <strong>external</strong> or
<strong>internal</strong>: from the latter we can extract the definition
of <strong>vulnerability</strong>, which is the property of the system
that allows an external agent to cause a fault.</p>
<p><strong>Example: Trapdoor.</strong> It’s a hidden entry within a
system that allows an attacker to bypass security measures.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>username <span class="op">=</span> read_username<span class="op">();</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>password <span class="op">=</span> read_password<span class="op">();</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>username <span class="op">==</span> <span class="ch">&#39;d</span><span class="er">ummy_user</span><span class="ch">&#39;</span><span class="op">){</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//note that the password is not checked</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    grant_access<span class="op">();</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>username<span class="op">.</span>isValid<span class="op">()</span> <span class="op">&amp;&amp;</span> password<span class="op">.</span>isValid<span class="op">()){</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    grant_access<span class="op">();</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>From the past example we can learn that, having in mind the
dependability tree, to achieve security only the authorized actions have
to be allowed, and the confidentiality and the integrity of the data
have appears in case of improper or unauthorized actions.</p>
<h3 id="dependability-attributes">Dependability attributes</h3>
<p>The dependability of a system can be described by a set of
attributes, measurable and quantifiable in terms of probabilities:</p>
<ul>
<li><strong>Availability</strong>: the readiness for correct
service;</li>
<li><strong>Reliability</strong>: the continuity of correct
service;</li>
<li><strong>Safety</strong>: the absence of catastrophic consequences on
the user and the environment;</li>
<li><strong>Confidentiality</strong>: the absence of unauthorized
disclosure of information;</li>
<li><strong>Integrity</strong>: the absence of improper system state
alterations;</li>
<li><strong>Maintainability</strong>: the ability to undergo
modifications and repairs.</li>
</ul>
<p>We also briefly present the concept of <strong>trust</strong> between
systems, that express the dependance of dependability of the system A
from the dependability of the system B.</p>
<p>From them, we can gave a new definition of dependability, based on
the frequency of the service failures:</p>
<blockquote>
<p>Dependability is the ability of the system to deliver the service in
accordance with the specification, avoiding that service failures occur
with a frequency that is greater than a certain threshold.</p>
</blockquote>
<p>The threshold should be derived from the system requirements, and
should consider frequency, duration and severity of the service
failures.</p>
<h2 id="taxonomy-of-faults">Taxonomy of faults</h2>
<h3 id="the-system-life-cycle">The system life cycle</h3>
<p>We define the <strong>system life cycle</strong> as the period of
time that starts from the conception of the system and continues until
the system is decommissioned. We’re going to consider only two phases of
the system life cycle: the <strong>development phase</strong>, during
which the system is designed and implemented, and the <strong>use
phase</strong>, during which the system is used to deliver the
service.</p>
<h4 id="development-phase">Development phase</h4>
<p>In this phase the system only interact with the <strong>development
environment</strong>, such as physical world, human developers, their
tools and possible facilities: in this phase development faults can be
introduced in the system.</p>
<h4 id="use-phase">Use phase</h4>
<p>In this phase the system interacts with the <strong>use
environment</strong>:</p>
<ul>
<li><strong>Physical environment</strong>: the system is subject to
physical stress, such as temperature, humidity, vibrations, etc;</li>
<li><strong>administrator</strong>: who manages the system;</li>
<li><strong>users</strong>: who interact with the system;</li>
<li><strong>providers</strong>: who delivers the system to the
users;</li>
<li><strong>infrastructure</strong>: everything that is needed to
support the system;</li>
<li><strong>intruders</strong>: who try to attack the system.</li>
</ul>
<p>The use phase alternates period of <strong>correct delivery</strong>
of the service, <strong>service outage</strong> and <strong>service
shutdown</strong>:</p>
<ul>
<li><strong>service outage</strong>: when the system has a service
failure, and it’s not able to deliver the service correctly;</li>
<li><strong>service shutdown</strong>: when the system is stopped for
maintenance or for other reasons. Note that maintenance may take place
during every period of time, and includes both repair and
modification.</li>
</ul>
<p>In fact, there is a taxonomy for the maintenance: if the system is
stopped for repair an active fault, then we have a <strong>corrective
maintenance</strong>; if the system is stopped for repair a dormant
fault, then we have a <strong>preventive maintenance</strong>; if the
system is stopped for modification, then we have an <strong>adaptive
maintenance</strong>, or <strong>augmentative maintenance</strong> if
the system is stopped for improvement.</p>
<p>$$</p>
<h3 id="faults-classification">Faults classification</h3>
<p>Given the fact that faults can’t be enumerated, it’s useful to
classify them in order to understand their nature and their effects,
because we can also identify the mechanisms that can be used to prevent
that specific class of faults.</p>
<figure>
<img src="../images/01/fault%20classification.png" width="400"
alt="Faults classification - Avizienis et al., 2004" />
<figcaption aria-hidden="true">Faults classification - Avizienis et al.,
2004</figcaption>
</figure>
<p>We identifies three main classes of faults:</p>
<ul>
<li><strong>development faults</strong>: faults that are introduced
during the development phase;</li>
<li><strong>physical faults</strong>: faults that affect the physical
components of the system;</li>
<li><strong>interaction faults</strong>: faults that includes all the
external faults.</li>
</ul>
<p>Overlapping classes are possible, so we’re able to identify 31
possible combinations of faults.</p>
<figure>
<img src="../images/01/fault%20combinations.png" width="400"
alt="Faults classification - Avizienis et al., 2004" />
<figcaption aria-hidden="true">Faults classification - Avizienis et al.,
2004</figcaption>
</figure>
<p>We’re going to analyze the most important classes of faults, having
in mind the previous figure.</p>
<h4 id="natural-faults">Natural faults</h4>
<p>They’re the faults numbered from <span
class="math inline">\(11\)</span> to <span
class="math inline">\(15\)</span> in the previous figure, and they’re
are mainly hardware faults caused by natural phenomena, without the
intervention of humans.</p>
<ul>
<li><strong>Production defect</strong>, <span
class="math inline">\(11\)</span>: a fault that is introduced during the
development;</li>
<li><strong>internal defect</strong>, <span class="math inline">\(12
\text{ and } 13\)</span>: a fault that is introduced during the use
phase, and it’s caused by the physical degradation of the
components;</li>
<li><strong>external defect</strong>, <span class="math inline">\(14
\text{ and } 15\)</span>: a fault that is introduced during the use
phase, and it’s caused by the physical stress of the environment,
outside the system boundaries.</li>
</ul>
<h4 id="human-made-faults">Human-made faults</h4>
<p>We can distinguish between <strong>malicious faults</strong>,
introduced with the intent to harm the system, and <strong>non-malicious
faults</strong>, introduced without any malicious intent.</p>
<p>The formers have as a goal to harm the system, the latter are divided
in two more classes:</p>
<ul>
<li><strong>non-deliberate faults</strong>: faults that are introduced
as human errors (<span class="math inline">\(1 \text{, } 2 \text{, } 7
\text{, } 8 \text{, } 16 \text{-}18 \text{, }
26\text{-}28\)</span>);</li>
<li><strong>deliberate faults</strong>: faults that are introduced as a
consequence of a deliberate action, such as a bad decision (<span
class="math inline">\(3 \text{, } 4 \text{, } 9 \text{, } 10 \text{, }
19 \text{-}21 \text{, } 29\text{-}31\)</span>).</li>
</ul>
<p>The latter can be introduced during <strong>development</strong> or
by <strong>interaction</strong>:</p>
<ul>
<li><strong>deliberate development faults</strong>: are generally the
result of a trade-off, both in terms of performance and economy (<span
class="math inline">\(3 \text{, } 4 \text{, } 9 \text{, }
10\)</span>);</li>
<li><strong>deliberate interaction faults</strong>: when operational
procedures are deliberately violated (<span class="math inline">\(19
\text{-}21 \text{, } 29\text{-}31\)</span>).</li>
</ul>
<p>In general, <strong>deliberate faults</strong> shows up only after an
unacceptable behavior of the system, and it can be difficult to realize
the actual faults because, when it happened, who introduced the fault
can be not conscious of the consequences of his action.</p>
<p>However, not all mistakes and dab decisions by non-malicious humans
are accidental: we can distinguish between <strong>accidental
faults</strong> and <strong>incompetence faults</strong>.</p>
<h4 id="interaction-faults">Interaction faults</h4>
<p>They can also be named as <strong>operational faults</strong>, given
the fact that they occour during the use phase, and they’re all
external, because they’re caused by the interaction between the system
and the environment. Classes from <span
class="math inline">\(16\)</span> to <span
class="math inline">\(31\)</span> are human made, and only <span
class="math inline">\(14\)</span> and <span
class="math inline">\(15\)</span> are natural.</p>
<p>A common feature of these faults is the fact that they usually need
the presence of a vulnerability in the system, that is a property of the
system that allows an external agent to cause a fault, both intentional
and unintentional.</p>
<p>Lastly, we recognize the <strong>permanent faults</strong>, that are
continuous and stable, and the <strong>transient faults</strong>, that
are temporary, even for very short periods of time.</p>
<h2 id="failures">Failures</h2>
<p>In order to characterize the failures, we use four different
dimensions, such that each of them can describe a different aspect of
the failure.</p>
<h3 id="failure-domain">Failure domain</h3>
<p>This point of view leads us to distinguish between <strong>content
failures</strong>, that are the result of the system’s inability to
deliver the correct service, and <strong>timing failures</strong>, that
are the result of the system’s inability to deliver the correct service
at the correct time (early, late, or never).</p>
<h3 id="consistency-domain">Consistency domain</h3>
<p>When a system has more than one user, it’s important to understand if
a failure shows up identically for each user, and we call this situation
<strong>consistent failure</strong>, or if the failure shows up
differently for each user, and we call this situation
<strong>inconsistent failure</strong>.</p>
<h3 id="detectability-domain">Detectability domain</h3>
<p>It’s the property of the system to check the correctness of the
service, and it’s the ability of the system to detect the failure. These
mechanisms have two failure modes:</p>
<ul>
<li><strong>false alarm</strong>: the system detects a failure when
there isn’t;</li>
<li><strong>missed detection</strong>: the system doesn’t detect a
failure when there is.</li>
</ul>
<h3 id="consequences-domain">Consequences domain</h3>
<p>Consequences of a failure are divided in two classes, based on their
severity and impact:</p>
<ul>
<li><strong>minor failure</strong>: the failure has a similar cost to
the benefit of the service;</li>
<li><strong>catastrophic failure</strong>: the failure has a cost that
is much greater than the benefit of the service.</li>
</ul>
<h3 id="criteria-to-evaluate-the-severity-of-a-failure">Criteria to
evaluate the severity of a failure</h3>
<p>We can use the following criteria to evaluate the severity of a
failure:</p>
<ul>
<li><strong>availability</strong>: the duration of the service
outage;</li>
<li><strong>safety</strong>: possible loss of life or injury;</li>
<li><strong>confidentiality</strong>: possible unauthorized disclosure
of information;</li>
<li><strong>integrity</strong>: data corruption and/or inability to
recover;</li>
</ul>
<h3 id="system-failures">System failures</h3>
<p>When a system has a failure, it is usually caused by different
coexisting faults; we talk about <strong>single fails</strong> if the
failure is caused by a single fault, and <strong>multiple fails</strong>
if the failure is caused by multiple faults. In the latter we can also
divide the faults in <strong>independent</strong> and
<strong>dependent</strong>, respectively if the faults are not related
to each other, and if the faults have a common cause.</p>
<h3 id="dependability-and-security-failures">Dependability and security
failures</h3>
<p>These failures occurs if the system suffers service failures more
frequently than an acceptable threshold; even the specifications of the
system can contain faults:</p>
<ul>
<li><strong>omission</strong>: a requirement is not included in the
specification;</li>
<li><strong>unjustified requirements</strong>: choice of requirements
that are not justified by the system’s function, that raises the cost of
the system.</li>
</ul>
<p>Systems can have different type of failures:</p>
<ul>
<li><strong>fail-controlled</strong>: the system is designed to fail in
a controlled way, described by the system’s specification;</li>
<li><strong>fail-stopped</strong>: the system in which possible failures
are only <em>haltings</em>;</li>
<li><strong>fail-silent</strong>: the system in which possible failures
are only <em>silents</em>;</li>
<li><strong>fail-safe</strong>: the system in which there are only minor
failures;</li>
</ul>
<h2 id="errors">Errors</h2>
<p>As we saw, an error is a part of the system state that is able to
lead to a failure. An error is detected if a signal to indicate its
presence in raised, otherwise the error is undetected and it’s called
<strong>latent error</strong>. It’s not true that every error leads to a
failure, and this depends on:</p>
<ul>
<li>the <strong>structure of the system</strong>, specially the presence
of redundancy;</li>
<li>the <strong>behavior of the system</strong>, for example the part of
the state that contains the error is never reached during the delivery
of the service, then the error is not able to lead to a failure.</li>
</ul>
<p>The classification of the error is done according to the damage
pattern (single, double or triple bit, burst, etc.), and how many
components are affected by the error (single, multiple, etc.).</p>
<h2
id="chain-of-threats---relationship-between-faults-errors-and-failures">Chain
of threats - Relationship between faults, errors and failures</h2>
<p>When systems have to interact with each other, an error propagation
can occur:</p>
<figure>
<img src="../images/01/chain%20of%20threats.png" width="400"
alt="Chain of threats - Avizienis et al., 2004" />
<figcaption aria-hidden="true">Chain of threats - Avizienis et al.,
2004</figcaption>
</figure>
<p>An <strong>active fault</strong> is when it leads to an error, both
if it’s internal or external, and it can lead to a failure, and a
<strong>fault activation</strong> occurs when a particular input
activates a dormant fault in a specific component. This can also be a
<strong>propagation</strong> between the components, where an error of a
component can lead to an error of another component.</p>
<p><strong>Example</strong>: error propagation</p>
<blockquote>
<p>Take a sensor which reports the spinning speed of a turbine. If the
sensor fails and starts to report that the turbine is no longer
spinning, it inject incorrect data (fault) into the control system, that
will send to the turbine the wrong commands, and the turbine could be
damaged (failure).</p>
</blockquote>
<h2 id="dependability-means">Dependability means</h2>
<p>When we talk about dependability means, we refer to the mechanisms
that are used to prevent, detect and tolerate, or in general deal, with
faults.</p>
<h3 id="fault-prevention">Fault prevention</h3>
<p>These techniques are usually related to general system design, and
they’re used to avoid the introduction of faults in the system. They can
be divided in two classes:</p>
<ul>
<li><strong>development fault prevention</strong>: techniques that are
used to avoid the introduction of faults during the development
phase;</li>
<li><strong>improved development process</strong>: techniques that are
used to improve the development process, such as the use of formal
methods, the use of a rigorous testing and so on.</li>
</ul>
<h3 id="fault-tolerance">Fault tolerance</h3>
<p>It’s the ability to deal with faults at run-time, and ensure that the
system is able to deliver the service even in presence of faults. There
are a lot of techniques that can be used to achieve fault tolerance, as
we can see in the following figure:</p>
<figure>
<img src="../images/01/tolerance.png" width="400"
alt="Fault tolerance techniques - Avizienis et al., 2004" />
<figcaption aria-hidden="true">Fault tolerance techniques - Avizienis et
al., 2004</figcaption>
</figure>
<h4 id="example-of-error-detection">Example of error detection</h4>
<p>For simplicity, let’s state that <em>when the error reaches the
boundaries of the systems, then we have a failure</em>. In this context,
the most challenging aspect are:</p>
<ul>
<li>the <strong>identification of the error</strong>, that is the
ability to detect the presence of the error;</li>
<li><strong>ensure that status containing the error is never
reached</strong>, that is the ability to avoid that the error leads to a
failure;</li>
<li>the <strong>prevention of the error propagation</strong>, that is
the ability to avoid that the error of a component leads to the error of
another component.</li>
</ul>
<p><strong>Example</strong>: error detection with two systems</p>
<blockquote>
<p>Take two systems, A and B, that should provide the same service. If
they get the same input, then they should provide the same output. If
the outputs are different, then we have a detection of the error, within
the hypothesis that the systems are independent and it’s very unlikely
that they have the same error at the same time.</p>
</blockquote>
<h3 id="fault-handling">Fault handling</h3>
<p>When we talk about fault handling, we refer to the mechanisms that
<strong>prevents faults from being activated again</strong>. It’s
composed by different phases:</p>
<ol type="1">
<li><strong>diagnois</strong>: the phase in which the system detects the
presence of the fault. Usually, a component is made in order to test
another components, and the aim is to identify and records the cause of
the error, in terms of location and type;</li>
<li><strong>isolation</strong>: to obtain the physical and/or logical
exclusion of the faulty component from the rest of the system;</li>
<li><strong>reconfiguration</strong>, such as thw switch to a redundant
component, or the use of a different path to reach the same
component;</li>
<li><strong>reinitialization</strong>: to restore the system to update
the system to the new configuration.</li>
</ol>
<p>In conclusion we state that the <strong>system recover is composed by
the error handling phase and the fault handling phase</strong>.</p>
<h3 id="fault-removal">Fault removal</h3>
<p>The fault removal is the process that is used to remove the faults
from the system, and it’s usually done during the development phase. The
main goal is to remove the faults that are present in the system, and to
prevent the introduction of new faults. It’s composed by different
phases, that we’ll see in the next sections:</p>
<h4 id="verification-phase">Verification phase</h4>
<p>The verification phase is the phase in which the system is tested to
verify that it meets the <strong>verification conditions</strong>. To do
that, there are two main methods:</p>
<ul>
<li>verification <strong>without execution</strong>: the system is
tested without executing it, and it’s usually done via inspection or
theory-proving. A state-transition diagram can be used to verify the
correctness of the system, and it’s applicable to various type of the
system, and applicable to fault tolerance mechanisms. Worth to mention
the fact that, in this type of verification errors and faults are
artificially injected as part of the test pattern;</li>
<li>verification <strong>by execution</strong>: the system is tested by
executing it, and it’s usually done via <strong>dynamic
verification</strong> (e.g. symbolic execution, testing both for
hardware and software), <strong>deterministic testing</strong> and
<strong>statistical testing</strong>.</li>
</ul>
<p>Another two steps are crucial:</p>
<ul>
<li><strong>verification of the mechanism</strong>: the verification of
the fault tolerance mechanism, and it’s usually done via <strong>fault
injection</strong>;</li>
<li><strong>verification of the system</strong>: ensure that the system
cannot do more than what is supposed to do, and it’s usually done via
<strong>penetration testing</strong>.</li>
</ul>
<p>To remove a fault during the exercise, both <strong>corrective
maintenance</strong> and <strong>preventive maintenance</strong>.</p>
<h3 id="fault-forecasting">Fault forecasting</h3>
<p>The fault forecasting is done by performing an evaluation of the
system behavior, with respect to fault occurrence and activation, and
it’s usually done via <strong>qualitative evaluation</strong> and
<strong>quantitative evaluation</strong>.</p>
<h3 id="error-recovery">Error recovery</h3>
<h4 id="error-compensation">Error compensation</h4>
<p>When we talk about fault tolerance, we’re in fact talking about
<strong>fault masking</strong>: a general method to achieve this goal is
<strong>performing multiple computations</strong> trough replicas, and
then apply a vote mechanism to the results. It’s worth to remember that
hardware faults <strong>fails independently</strong> and, on the
contrary, software faults <strong>fails dependently</strong>: to achieve
a sort of independence, we can use <strong>design diversity</strong>,
that is the use of different design techniques to implement the same
function.</p>
<p><strong>Example</strong>: error compensation with TMR</p>
<blockquote>
<p>Take a system that uses a <strong>Triple Modular Redundancy</strong>
(TMR) to achieve fault tolerance. The system has three replicas, and the
output is the result of a majority vote. If one of the replicas fails,
then the output is still correct, because the other two replicas are
still able to provide the correct output.</p>
</blockquote>
<h4 id="organization-of-fault-tolerance">Organization of fault
tolerance</h4>
<p>We can summarize the organization of fault tolerance in the following
figure:</p>
<figure>
<img src="../images/01/summary.png" width="400"
alt="Organization of fault tolerance - Avizienis et al., 2004" />
<figcaption aria-hidden="true">Organization of fault tolerance -
Avizienis et al., 2004</figcaption>
</figure>
<p>WE just have to add some definitions:</p>
<ul>
<li><strong>solid faults</strong> are those that are permanent and their
activation is repeatable;</li>
<li><strong>elusive faults</strong> are those that are permanent and
their activation is not systematically reproducible;</li>
<li><strong>intermittent faults</strong> are those with transient
physical or interaction faults, and their activation is not
systematically reproducible.</li>
</ul>
<p>Remember that the classes of faults that can be actually tolerated
depend on the fault assumption that is being considered in the
development process, and on the independence of the redundant components
that are used to achieve fault tolerance.</p>
<h2 id="error-detection">Error detection</h2>
<p>The error detection is the ability of the system to detect the
presence of an error, and different strategies can be used to achieve
this goal, such as:</p>
<ul>
<li><strong>replication checks</strong>: the use of multiple replicas to
perform the same computation, and then compare the results, under the
assumption that the replicas fail independently;</li>
<li><strong>reasonability checks</strong>: the use of a model of the
system to check the reasonability of the output, and then compare the
output with the model;</li>
<li><strong>run-time checks</strong>: mechanisms provided via hardware
or software, like division by zero, array bounds, etc.</li>
<li><strong>specification-based checks</strong>: the use of the problem
specification to check the correctness of the output (e.g. to find a
solution to an equation, we can substitute the result in the equation
and check if the result is correct);</li>
<li><strong>reversal checks</strong>: the use of the inverse function to
check the correctness of the output.</li>
<li><strong>structural checks</strong>: the use of known properties of
the system to check the correctness of the output.</li>
<li><strong>timing checks</strong>: the use of watchdogs to check the
timing of the system.</li>
<li><strong>codes</strong>: the use of codes to check the correctness of
the output (e.g. parity, checksum, etc.).</li>
</ul>
<h3 id="structural-approach-to-error-detection">Structural approach to
error detection</h3>
<p>The main goal is to prevent the propagation of the error, and to
achieve that some structural properties should be set to help the
system.</p>
<h4 id="principle-of-least-privilege">Principle of least privilege</h4>
<p>the concept of <strong>minimum privilege</strong> is crucial, and
it’s the idea that a component should have the minimum privilege to
perform its function, and nothing more. Following this idea, we should
consider the fact that <strong>no action is permissible unless it is
explicitly allowed</strong>, also known as the concept of <strong>mutual
suspicion</strong>.</p>
<h4 id="system-modularization-and-partitioning">System modularization
and partitioning</h4>
<p>Remembering the fact that a system should be modularized, we can use
the <strong>modularization</strong> to prevent the propagation of the
error, adding to each module an error detection (and possibly recovery)
mechanism, in order to confine the error to the module in which it
occurred and don’t let it spread to the other modules. The last
reasoning is also valid for the <strong>partitioning</strong> of the
system, when modules act independently and the error can’t spread to the
other modules.</p>
<h4 id="temporal-structuring">Temporal structuring</h4>
<p>Another thing to take in consideration is the <strong>temporal
structuring</strong> of the activities between the modules, for those
operations only between two specific modules that don’t communicate with
the rest of the system. We also introduce the concept of <strong>atomic
action</strong>, that is an action that is performed in a single step,
and it’s not possible to interrupt it: if a failure occurs, only the
participating actions are affected.</p>
<h3 id="measurement-of-effectiveness-of-error-detection">Measurement of
effectiveness of error detection</h3>
<p>Different metrics can be used to measure the effectiveness of the
error detection, such as:</p>
<ul>
<li><strong>coverage</strong>: the probability that an error is
detected, given that it actually occurs;</li>
<li><strong>latency</strong>: the time that elapses between the
occurrence of the error and its detection;</li>
<li><strong>damage confinement</strong>: the probability that the error
is confined to the component in which it occurred;</li>
<li><strong>forward recovery</strong>: the probability that the system
is able to recover from the error, transforming the erroneous state into
a <strong>new</strong> correct state;</li>
<li><strong>backward recovery</strong>: the probability that the system
is able to recover from the error, transforming the erroneous state into
the <strong>previous</strong> correct state.</li>
</ul>
<p>It’s worth to spent some words for the last two metrics, that will be
discussed in the next section.</p>
<h4 id="forward-recovery">Forward recovery</h4>
<p>This technique requires to <strong>asses the damage cause</strong> by
the detected error <strong>propagates before detection</strong>, and
it’s usually implemented ad-hoc for the specific system. An effective
<strong>example</strong> is the following:</p>
<blockquote>
<p>In a real time control system, a situation when input a sensor input
is occasionally missed is tolerable, and the system should implement a
forward recovery by skipping its response of the missed input.</p>
</blockquote>
<h4 id="backward-recovery">Backward recovery</h4>
<p>This technique is a little bit more complex, because <strong>requires
a previous correct state</strong> to be restored, also called
<strong>checkpoint</strong>, and can be tedious, especially in case when
multiple modules are involved, because we need to restore a
<strong>consistent checkpoint</strong> for each of them, as we can see
in the following figure:</p>
<figure>
<img src="../images/01/backwards.png" width="400"
alt="Backward recovery - C. Bernardeschi" />
<figcaption aria-hidden="true">Backward recovery - C.
Bernardeschi</figcaption>
</figure>
<p>In this image we see the checkpoint, as circle, the passed messages
between the modules, and the error that occurs with a <span
class="math inline">\(X\)</span>: to avoid a <strong>domino
effect</strong>, we need to restore a consistent checkpoint for each
module, also considering their communications, remembering the concept
of atomic action.</p>
<p>The basic issues of backward recovery are:</p>
<ul>
<li>loss of computation time between the checkpoint and the
rollback;</li>
<li>loss of data between the checkpoint and the rollback;</li>
<li>the need of a specific mechanism that implements the rollback;</li>
<li>the increase of the overhead of the system, in order to restore the
correct state.</li>
</ul>
<p>The class of faults that gain benefits from the backward recovery are
the <strong>transient faults</strong>, because they usually disappear
after a short period of time, in <strong>parallel computing</strong>, to
avoid a complete restart of the system, and in <strong>real-time
systems</strong>, to avoid the loss of the real-time constraints.</p>
<p>On the other hand, the class of faults that are not suitable for the
backward recovery are the <strong>hardware and design faults</strong>,
because the system will always do the same action, resulting in the same
error.</p>
<h3 id="the-exception-handling">The exception handling</h3>
<p>The exception handling is a mechanism that is used to deal with the
errors, and it’s usually implemented via software, and it’s used to deal
with the errors that are detected at run-time. The main goal of the
exception handling is to avoid the propagation of the error, and to
restore the system to a consistent state. Three are the main classes of
exceptions:</p>
<ul>
<li><strong>interface exceptions</strong>: exceptions that are raised
when the system receives an input that is not in accordance with the
specification, handled by the module that requests the service;</li>
<li><strong>internal local exceptions</strong>: exceptions that are
raised when the system detects an error in its own state, handled by the
module itself;</li>
<li><strong>failure exceptions</strong>: exceptions that are not handled
by the mechanism, communicated to the user.</li>
</ul>
<h1 id="redundancy-in-fault-tolerant-computing">Redundancy in Fault
Tolerant Computing</h1>
<p>In this chapter we’ll se how to use redundancy to improve the
reliability of a system. There are various types of redundancy, and
we’ll go through them one by one.</p>
<h2 id="hardware-redundancy">Hardware Redundancy</h2>
<p>Briefly, hardware redundancy is the physical replication of the
hardware components of a system. This is done to ensure that if one
component fails, the system can continue to operate using the redundant
component. In this category we can find <strong>passive</strong>,
<strong>active</strong> and <strong>hybrid</strong> redundancy.</p>
<h3 id="passive-fault-tolerance-techniques">Passive fault tolerance
techniques</h3>
<p>In passive tolerance, the <strong>fault masking</strong> is the
keystone of the technique: a <strong>voting mechanism</strong> is
implemented upon the redundant components, and the output of the system
is the result of the majority of the components. This way, if one
component fails, the system can continue to operate using the redundant
component, and <strong>without any external intervention</strong>.</p>
<h4 id="triple-modular-redundancy-tmr">Triple Modular Redundancy
(TMR)</h4>
<p>This technique is schematized in the following figure:</p>
<figure>
<img src="../images/02/tmr.png" width="300"
alt="Scheme of a TMR implementation - C.Bernardeschi" />
<figcaption aria-hidden="true">Scheme of a TMR implementation -
C.Bernardeschi</figcaption>
</figure>
<p>The main idea is to <strong>triplicate</strong> the specific
component, and perform a <strong>majority voting</strong> on the
outputs. This technique obviously needs the assumption that the
<strong>probability of failure of the components is
independent</strong>, but ensure a fault neutralization without the need
of any external intervention, and this for each of the components.</p>
<p>TMR is very effective when we’re dealing with <strong>transient
faults</strong>, but on the contrary isn’t very helpful when dealing
with <strong>permanent faults</strong>, and this because the fault
tolerance decreases since the faulty component remains in the
system.</p>
<h4 id="cascaded-tmr-with-triplicated-voters">Cascaded TMR with
triplicated voters</h4>
<p>This technique is a further development of the TMR, and is
schematized in the following figure:</p>
<figure>
<img src="../images/02/CTMR.png"
alt="Scheme of a cascaded TMR with triplicated voters - C.Bernardeschi" />
<figcaption aria-hidden="true">Scheme of a cascaded TMR with triplicated
voters - C.Bernardeschi</figcaption>
</figure>
<p>The effect of partitioning the modules is that the design can now
withstands more failures than the TMR, thanks to the multiple voters.
Unfortunately, we can let this technique arbitrarily reliable, because
the reliability of the system is limited by the <strong>reliability of
the voters</strong>, which also are a <strong>single point of
failure</strong>.</p>
<h4 id="the-voter">The Voter</h4>
<p>The voter is a crucial component in the previous techniques: it’s
usually implemented as an hardware digital circuiting, and it’s
responsible for the majority voting. This leads to difficulties on its
implementation:</p>
<ul>
<li><strong>delay on signal propagation</strong>: the voter must wait
for the inputs to be stable before performing the voting, waiting for
the synchronization of the inputs;</li>
<li>trade-off between <strong>achieved fault tolerance</strong> and
<strong>cost</strong> in hardware complexity.</li>
</ul>
<p>There is also another main problem, that come out when we’re dealing
with <strong>analog signals</strong>: in this case, the majority voting
is not so straightforward, and the voter must be implemented as a
<strong>digital-to-analog converter</strong>. Given that these converter
could produce inconsistent results, another techniques are implemented
to ensure the correct voting, such as:</p>
<ul>
<li><strong>average of the signals</strong>;</li>
<li>choose the <strong>mean of similar signals</strong>;</li>
<li>choose the <strong>median of the signals</strong>.</li>
</ul>
<h4 id="n-modular-redundancy-nmr">N-Modular Redundancy (NMR)</h4>
<p>This technique is a generalization of the TMR, when the number of
redundant components, which <strong>must be odd</strong>, is arbitrary.
Using this method, we can cover up to <span
class="math inline">\(m\)</span> faulty modules, such that <span
class="math inline">\(N = 2m+1\)</span>. The main problem of this
technique is that the number of voters grows with the number of
redundant components, and this leads to a <strong>high
cost</strong>.</p>
<h3 id="active-fault-tolerance-techniques">Active fault tolerance
techniques</h3>
<p>In active tolerance, redundancy is used in a <strong>dynamic
way</strong>, through fault detection, location and recovery. Briefly,
the existence of faults is detected, and some actions are taken in order
to remove the faulty component from the system, and replace through a
reconfiguration. These techniques are used in context where temporary
faults while the system is being reconfigured are acceptable.</p>
<h4 id="duplication-with-comparison-scheme">Duplication with comparison
scheme</h4>
<p>Two identical pieces of hardware are used, performing the same
computation in parallel, with a comparator that takes as input their
results. If the results differs, a failure is detected and an error
signal is generated. The technique has a good coverage ratio, because
it’s able to detect <strong>every faults</strong>, except fot those that
affect the comparator: worth to mention is the simplicity and the low
cost, with a minimal impact on the performance. On the other hand, we
have to deal with the possibility that the comparator itself could
fails, leading to both false positives and false negatives.</p>
<h4 id="reconfigurable-duplication">Reconfigurable Duplication</h4>
<p>This technique is a further development of the previous one, and is
schematized in the following figure:</p>
<figure>
<img src="../images/02/ReconfDuplication.png"
alt="Scheme of a reconfigurable duplication - C.Bernardeschi" />
<figcaption aria-hidden="true">Scheme of a reconfigurable duplication -
C.Bernardeschi</figcaption>
</figure>
<p>The circuit works like the previous one, with the difference that the
output of the comparator is used as input of the switch, in order to
select the module that will be used as output, with the implicit
hypothesis that the comparator is able to select the correct value in
case of disagreement. To do that, checks such as coding, reversal or
reasonable checks are performed, and the switch is used to select the
correct output disconnecting the faulty module. This configuration is
also called <strong>duplex system</strong>.</p>
<h4 id="stand-by-sparing">Stand-by sparing</h4>
<p>As we can see in the schema, modules can be
<strong>operational</strong> or <strong>spares</strong>:</p>
<figure>
<img src="../images/02/spares.png" width="400"
alt="Scheme of a stand-by sparing - C.Bernardeschi" />
<figcaption aria-hidden="true">Scheme of a stand-by sparing -
C.Bernardeschi</figcaption>
</figure>
<p>The switch implements the <strong>fault detection and
localization</strong>, and can decide to no longer use a module if it’s
faulty, and to replace it with a spare. Spares are divided in three
categories:</p>
<ul>
<li><strong>hot spares</strong>: they are always active, and ready to
replace a faulty module in every moment;</li>
<li><strong>warm spares</strong>: they are running, but receives inputs
from the system only when they are activated;</li>
<li><strong>cold spares</strong>: they are off, and must be activated
before being used.</li>
</ul>
<p>A <strong>pair-and-spare</strong> approach can also be used, when
every module is a <strong>duplex system</strong>, connected to the
switch with a comparator: as long as the outputs agree, the spares are
not used, but in case of disagreement, the switch operates the
replacement.</p>
<h3 id="hybrid-fault-tolerance-techniques">Hybrid fault tolerance
techniques</h3>
<p>In this category, we can find the <strong>combination</strong> of the
previous techniques, in order to obtain a better fault tolerance. The
main idea is to combine the advantages of the previous techniques, and
to mitigate their disadvantages. Intuitively, we can say that costs
increase dramatically, such as the complexity of the implementations, so
this techniques are used only in <strong>critical systems</strong>.</p>
<h4 id="reconfigurable-nmr">Reconfigurable NMR</h4>
<p>This technique is a combination of the NMR and the reconfigurable
duplication, and is schematized in the following figure:</p>
<figure>
<img src="../images/02/reconfNMR.png" width="300"
alt="Scheme of a reconfigurable NMR - C.Bernardeschi" />
<figcaption aria-hidden="true">Scheme of a reconfigurable NMR -
C.Bernardeschi</figcaption>
</figure>
<p>There are <span class="math inline">\(N\)</span> redundant modules,
and the voter; the <strong>fault detection units</strong> compare the
outputs of the voters with the output of the active modules, and replace
the faulty module with a spare, isolating it from the system. The
reliability of the circuit holds as longs as the number of spare modules
isn’t zero, and the coverages depends on the number of spare: a TMR with
one spare can tolerates up to two faults, by masking the first module,
replacing it and possibly mask the second one.</p>
<h3 id="summary-of-the-hardware-redundancy-techniques">Summary of the
hardware redundancy techniques</h3>
<p>The key differences between the techniques are summarized:</p>
<ul>
<li><strong>passive</strong> rely on the <strong>fault masking</strong>,
and requires high investments in the hardware;</li>
<li><strong>active</strong> rely on the <strong>error
detection</strong>, <strong>fault localization</strong> and
<strong>recovery</strong>, but has the disadvantage of needing
additional hardware to detect and recover from the faults, and can
produced <strong>transient errors</strong>;</li>
<li><strong>hybrid</strong> are a combination of the previous
techniques. The reliability of the system is increased, but the costs
are the highest.</li>
</ul>
<h2 id="information-redundancy">Information Redundancy</h2>
<p>When we talk about information redundancy, we’re referring to
<strong>coding</strong>, that is the application of the redundancy
within the information itself. This is done using more bits than
strictly necessary to represent the information: if <span
class="math inline">\(n\)</span> is the number of bits needed to
represent the information, we use <span class="math inline">\(m = n +
c\)</span> bits, such that among all the possible <span
class="math inline">\(2^m\)</span> combinations, only <span
class="math inline">\(2^n\)</span> represents acceptable information,
and these combinations are called <strong>codewords</strong>; if a
non-codeword is received, an error is detected.</p>
<p><strong>Coding</strong> needs a phase of <strong>encoding</strong>,
where the <span class="math inline">\(c\)</span> bit are calculated and
added to the information, and a phase of <strong>decoding</strong>,
where the information is extracted from the codeword. We refer to
<strong>separable code</strong> when the information and the redundancy
are clearly separated,such as a concatenation of the information and the
redundancy, and to <strong>non-separable code</strong> when the
information and the redundancy are mixed together.</p>
<h3 id="parity-codes">Parity codes</h3>
<p>The simplest form of coding is the <strong>parity code</strong>,
where a single bit is added to the information, such that the number of
1s in the codeword is even or odd. This technique is very simple, but is
able to detect only <strong>single bit errors</strong>, and can’t
correct them.</p>
<p><strong>Example</strong>:</p>
<blockquote>
<p>with <span class="math inline">\(n=2\)</span> and <span
class="math inline">\(m=3\)</span>, 8 are the possible combinations, and
4 are the codewords. We can easily get that the codewords are <span
class="math inline">\(001\)</span>, <span
class="math inline">\(010\)</span>, <span
class="math inline">\(100\)</span> and <span
class="math inline">\(111\)</span>.</p>
</blockquote>
<h3 id="complemented-duplication">Complemented duplication</h3>
<p>In this technique, the information is duplicated, having <span
class="math inline">\(n\)</span> bits of information and <span
class="math inline">\(n\)</span> bits of redundancy, such that the
redundancy is the complement of the information. In this case, having
<span class="math inline">\(n=4\)</span>, we can have 16 possible
combinations, and 4 are the codewords.</p>
<h3 id="hamming-distance">Hamming distance</h3>
<p>We define the <strong>Hamming distance</strong> has it follows:</p>
<blockquote>
<p>Given two codewords <span class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span>, the Hamming distance between them is
the number of bits in which they differ.</p>
</blockquote>
<p>The <strong>minimum Hamming distance</strong> between two codewords
is the number of independent single bit errors that the code can detect;
a code such that the Hamming distance is $ &gt; k$ will detect up to
<span class="math inline">\(k\)</span> erroneous bits.</p>
<p>The main concept is that <strong>the corrupted data is closer to the
correct data than to any other codeword</strong>. In the following
figure, we can see a generic example of the Hamming distance, with the
differences between predictable and unpredictable errors.</p>
<figure>
<img src="../images/02/hamming.png" width="300"
alt="Hamming distance - C.Bernardeschi" />
<figcaption aria-hidden="true">Hamming distance -
C.Bernardeschi</figcaption>
</figure>
<h3 id="checksums">Checksums</h3>
<p>This method is usually applied to large blocks of data, and it’s able
to cover a single fault. The checksum for a block of <span
class="math inline">\(n\)</span> words is formed by adding together all
the words modulo <span class="math inline">\(k\)</span>, with <span
class="math inline">\(k\)</span> arbitrary. The checksum is then stored
in the data block, and when the block is transmitted, the checksum is
recalculated and compared with the stored one; the codeword in this case
is composed by the entire block of data, and the actual checksum.</p>
<p>The main disadvantages of the technique are:</p>
<ul>
<li>the need to recalculate the checksum every time the data is
modified;</li>
<li>the error detection is limited is allowed, but the error
localization is not possible.</li>
<li>it represents a single point of failure.</li>
</ul>
<h3 id="ecc">ECC</h3>
<p>This technique enables the <strong>error location</strong> for
single-bit error, as we can see in the following figure:</p>
<figure>
<img src="../images/02/ECC.png" width="300"
alt="ECC - C.Bernardeschi" />
<figcaption aria-hidden="true">ECC - C.Bernardeschi</figcaption>
</figure>
<h3 id="hamming-codes">Hamming codes</h3>
<p>This technique is usually used in databases, with specific disks that
implements that mechanism, and it’s based on <strong>spreading parity
bits across the data</strong>. The main idea is to use the
<strong>parity bits</strong>, that are all bit in positions that are a
power of 2, to check the data, and to use the <strong>data bits</strong>
to store the information. In this way, the data bits are included in a
set of two or more parity bits, and the parity bits are included in a
set of two or more data bits, implementing a <strong>detection and
correction</strong> mechanism. In the figure we can see an example of
the Hamming code:</p>
<figure>
<img src="../images/02/hammingCode.png"
alt="Hamming code - Wikipedia" />
<figcaption aria-hidden="true">Hamming code - Wikipedia</figcaption>
</figure>
<p>The parity bit <span class="math inline">\(p_j\)</span> covers all
the bit whose position has the <span class="math inline">\(j\)</span>-th
bit set to 1, so every data bit is covered by a set of parity bits.</p>
<h3 id="self-checking-circuitry">Self-checking circuitry</h3>
<p>In order to implements all the previous methods, we have the
necessity of reliability on the modules that performs checks and
comparisons, and this is done through the <strong>self-checking
circuitry</strong>.: given a set of faults, the circuit has the ability
to <strong>automatically detect</strong> the fault, during the normal
course of its operations; this is usually achieved by implementing
coding techniques in the circuitry, such that input and outputs are
encoded. . Three are the main techniques:</p>
<ul>
<li><strong>self-testing</strong> circuitry: if, for every fault from
the set, does exists a non-code output;</li>
<li><strong>fault-secure</strong> circuitry: if, for every fault from
the set, the circuit never produces an incorrect output for any
input;</li>
<li><strong>totally self-checking</strong> circuitry: if the circuit is
both self-testing and fault-secure.</li>
</ul>
<h2 id="time-redundancy">Time Redundancy</h2>
<p>To avoid the need (and the expense) of additional hardware, we can
use another type of redundancy, called <strong>time redundancy</strong>:
the main idea is to exchange the <strong>expense of the
hardware</strong> with the <strong>expense of the time</strong>.</p>
<h3 id="repetition-of-the-computation">Repetition of the
computation</h3>
<p>If we implement the time redundancy in this way, we have to
<strong>perform multiple time</strong> the same computation: it appears
obvious that <strong>permanent faults cannot be detected</strong>, given
the fact that the latter lead the system to always have the same error,
but instead it’s effective against <strong>transient faults</strong>. We
have also the problem to guaranteeing that the computation is performed
in the same way and with the same data, and the non-negligible
overhead.</p>
<h2 id="software-redundancy">Software Redundancy</h2>
<p>As we briefly said in the previous chapter, the software is subject
to both <strong>operational faults</strong> and <strong>design
flaws</strong>. In particular, the latter is due to
<strong>ambiguities</strong> in the specifications, or in mistakes made
during the implementation. They’re hard to visualize, and they’re also
closely related to a human factor: if, for example, only specific inputs
trigger a fault, the number of failures depends on the number of times
the inputs are used; it’s also true that the <strong>apparent
reliability</strong> of a software is more due to the number of the
exercised design faults, rather than the actual number of design faults
present in the software. Given these premises, and the fact that the
software has a large cost of development, the main focuses of software
reliability are made on the <strong>fault prevention</strong> and
<strong>testing strategies</strong>, usually with a
<strong>multi-version</strong> approach.</p>
<h3 id="software-diversity">Software diversity</h3>
<p>Implementing two (or more) identical version of the software, these
versions will always fail not in a independent way, leading to an
inability to detect possible software faults. For this reason, the
versions must be <strong>diverse</strong>: they obviously must be
functionally equivalent, but their development must be carried out by
different teams, using different tools and different algorithms.
Developing <span class="math inline">\(N\)</span> different versions,
the need of a decision mechanism is necessary, and this is usually
implemented through a <strong>voting mechanism</strong>.</p>
<h4 id="disadvantages-and-practical-considerations">Disadvantages and
practical considerations</h4>
<p>When using software diversity, we have to deal with the higher cost
for development and concurrent execution of the software, and the
possibility to have <strong>correlated errors</strong>, due to
specification mistakes that shouldn’t be tolerated. A practical concern
over the voting mechanism is that every version will have different
compilers and formats for data types, that must be taking into account
when implementing the voting mechanism.</p>
<h3 id="n-version-programming">N-version programming</h3>
<h4 id="the-voter-1">The voter</h4>
<p>Some considerations we made in the previous sections, when we talked
about hardware redundancy, are also valid for software redundancy: the
voter is still a <strong>single point of failure</strong>, and it’s not
replicated, in order to remain simple and verifiable.</p>
<p>New tasks for the voter are that must <strong>verify the consistency
of input data</strong> within the different versions, and must be able
to receive data in a identical format from every version, both
implementing a communication protocol and/or a efficient data
conversion.</p>
<h4 id="n-version-self-check-programming">N-version self-check
programming</h4>
<p>This circuit is based on the <strong>acceptance tests</strong> rather
than the comparison between equivalent version: the voter implements
some sort of selection logic that takes as input only the results from
the versions whose output passed the specific-version acceptance tests,
tolerating up to <span class="math inline">\(N-1\)</span> faults.</p>
<h3 id="design-diversity">Design diversity</h3>
<p>This technique is based on the fact that the <strong>same
specification can be implemented in different ways</strong>, and the
different implementations can be used to check each other. The main idea
is to use different algorithms, data structures and programming
languages, and to use the same inputs to check the outputs.
Unfortunately, as we said before, it’s not possible to assume that these
versions will fail independently, and this is due to the fact that the
same specification can be implemented in different ways, but the same
design flaws can be present in the different implementations: it’s in
fact true that, from empirical studies, that common faults are pretty
common, but at the same time, implementing the diversity delivers actual
improvements in the reliability.</p>
<h1
id="basic-building-blocks-in-fault-tolerant-distributed-systems">Basic
building blocks in Fault tolerant distributed systems</h1>
<h2 id="atomic-actions">Atomic actions</h2>
<p>We intend as atomic an action that is indivisible, that is, it is
executed in its entirety or not at all. In a distributed system, an
atomic action is generally executed at more than one node, so these
nodes have to cooperate in order to guarantee the atomicity property: if
one of the nodes fails, the action shouldn’t let its effects be visible
to the entire system.</p>
<h3 id="atomic-actions-in-a-database">Atomic actions in a database</h3>
<p>In a database, an atomic action is a transaction, that can be
composed by more than one operation such as read, write, update or
deleted a record in the database.</p>
<h4 id="commit">Commit</h4>
<p>When a transaction is committed, all its effects are made visible to
the entire system. This means that the transaction is finished and its
effects are permanent. An example of a transaction is a bank transfer,
where the money is removed from one account and added to another
account, as we can see in the following example:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>t: <span class="cf">begin</span> <span class="kw">transaction</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UPDATE</span> <span class="kw">account</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> balance <span class="op">=</span> balance <span class="op">+</span> <span class="dv">500</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> account_number <span class="op">=</span> <span class="dv">45</span>;</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UPDATE</span> <span class="kw">account</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> balance <span class="op">=</span> balance <span class="op">-</span> <span class="dv">500</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> account_number <span class="op">=</span> <span class="dv">35</span>;</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>t: <span class="kw">commit</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span> <span class="kw">transaction</span></span></code></pre></div>
<h4 id="abort-or-rollback">Abort or Rollback</h4>
<p>When a transaction is aborted, all its effects are discarded and the
system is restored to the state it was before the transaction started.
An example of a transaction that is aborted is a bank transfer where the
money is added to one account but not removed from the other account
because of balance insufficiency, as we can see in the following
example:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>t: <span class="cf">begin</span> <span class="kw">transaction</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UPDATE</span> <span class="kw">account</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> balance <span class="op">=</span> balance <span class="op">+</span> <span class="dv">500</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> account_number <span class="op">=</span> <span class="dv">45</span>;</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UPDATE</span> <span class="kw">account</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> balance <span class="op">=</span> balance <span class="op">-</span> <span class="dv">500</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> account_number <span class="op">=</span> <span class="dv">35</span>;</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> balance</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">INTO</span> V <span class="kw">FROM</span> <span class="kw">account</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> account_number <span class="op">=</span> <span class="dv">35</span>;</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">IF</span> V <span class="op">&gt;=</span><span class="dv">0</span> <span class="cf">THEN</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">commit</span>;</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">ELSE</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        abort;</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">END</span> <span class="cf">IF</span>;</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>;</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span> <span class="kw">transaction</span></span></code></pre></div>
<h3 id="atomic-actions-in-a-distributed-system">Atomic actions in a
distributed system</h3>
<p>Imagine now that the bank database is distributed, and the two
accounts are stored in two different nodes. In this case, the
transaction has to use data stored in different nodes: a possible
rollback of the transaction must leave both nodes in a consistent state,
that is, the state they were in before the transaction started. Using
the previous codes as an example, the DBMS has to guarantee that if the
transaction is aborted, the money is not added to the first account and
the money is not removed from the second account, considering the fact
that these information are stored in different nodes.</p>
<h3 id="two-phase-commit">Two-phase commit</h3>
<p>The two-phase commit is a protocol that guarantees that a transaction
is either committed or aborted in a distributed system. We have some
crucial elements to consider:</p>
<ul>
<li>the <strong>transaction manager TM</strong>, that is the entity that
coordinates the transaction;</li>
<li>some <strong>resource managers RM</strong>, that are the entities
that manage the resources involved in the transaction.</li>
<li>a <strong>log file</strong>, stored in persistent memory, that is
used to recover the state of the transaction in case of failure;</li>
<li>a <strong>timeout</strong>, that is the maximum time that the TM
waits for a response from the RMs.</li>
</ul>
<p>A scheme of the two-phase commit is the following:</p>
<figure>
<img src="../images/03/twoPhase.png" width="400"
alt="Two-phase commit" />
<figcaption aria-hidden="true">Two-phase commit</figcaption>
</figure>
<p>In case of fail of the TM, we have an <strong>uncertain
period</strong>, during which a RM with a ready state cannot terminate
the transaction. Note that this mechanism is able to tolerates both loss
of messages and crash of nodes, simply rolling back the transaction.</p>
<h3 id="three-phase-commit">Three-phase commit</h3>
<p>This protocol is an evolution of the previous one, where a
<strong>pre commit</strong> phase is added. Assuming a permanent crash
of the TM, a participant is able to substitute the coordinate, in order
to terminate the transaction, with a <strong>global commit</strong> or a
<strong>global abort</strong>.</p>
<figure>
<img src="../images/03/threePhase.png" width="400"
alt="Three-phase commit" />
<figcaption aria-hidden="true">Three-phase commit</figcaption>
</figure>
<h3 id="recovery-and-atomicity">Recovery and atomicity</h3>
<p>Given a block <span class="math inline">\(B\)</span>, that can be a
<strong>physical block</strong> (a disk block) or a <strong>buffer
block</strong> (temporary storage in memory), the operations to move a
block from a disk to a buffer are <strong>input(B)</strong> and
<strong>output(B)</strong>. A transaction <span
class="math inline">\(T_i\)</span> has its own private work-area, in
which local copies of all accessed items are stored, performing the
operations <strong>read_item(X)</strong> and
<strong>write_item(X)</strong>. The system can perform the
<strong>output</strong> of the operation, trough the
<strong>output(<span class="math inline">\(B_X\)</span>)</strong>
operation, that need not immediately follows the
<strong>write_item(X)</strong> operation.</p>
<p>In general, several outputs are required by a transaction, and the
latter can be aborted after one of these operations have been made
permanent; it’s also true that a transaction can be committed, and a
failure can occur before all the outputs are made permanent. In order to
guarantee the atomicity property, the system has to perform the
<strong>output</strong> operation in a way that the transaction is
either committed or aborted, and the <strong>output</strong> operation
is either made permanent or not, using a <strong>log file</strong> to
recover the state of the transaction in case of failure.</p>
<h3 id="log-file">Log file</h3>
<p>The log file is a file stored in persistent memory, that is used to
recover the state of the transaction in case of failure. Before the
commit of a transaction, system has to save into the log file all the
records of the operations that have been made permanent, and after the
commit of a transaction, system has to save into the log file a record
that indicates the commit of the transaction, executing
<strong>UNDO</strong> and <strong>REDO</strong> operations in case of
failure, to restore the state of the transaction.</p>
<h2 id="consensus-problem">Consensus problem</h2>
            </div>
    </div>
  </div>
  <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>

</body>
</html>
