<!doctype html>
<html  lang="it" >
<head>
    <style>
		#TOC {
			overflow-y: hidden !important; 
			font-size: smaller !important;
			/*margin-right: 20px;*/
		}

		p, h1, h2, h3, h4, h5, a, span, li, ul, ol, th, tr, table, figcaption {
			font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Open Sans","Helvetica Neue",sans-serif !important;
		}

		[class*="span"] {
			margin-left: 0 !important;
		}

		.well {
			min-height: 0px !important;
			padding: 0px !important;
			margin-bottom: 0px !important;
			background-color: #FFFFFF  !important;
			border: 0 !important;
			-webkit-border-radius: 0 !important;
			-moz-border-radius: 0 !important;
			border-radius: 0 !important;
			-webkit-box-shadow: none !important;
			-moz-box-shadow: none !important;
			box-shadow: none !important;
		}

		.navbar-inner {
			background-color: #fefefe !important;
			background-image: none !important;
			background-repeat: no-repeat !important;
			filter: none !important;
			border: 0 !important;
			-webkit-border-radius: 0px !important;
			-moz-border-radius: 0px !important;
			border-radius: 0px !important;
			margin-bottom: 15pt !important;

			-webkit-box-shadow: 0 1px 10px rgb(0 0 0 / 7%) !important;
			-moz-box-shadow: 0 1px 10px rgba(0,0,0,.07) 1 !important;
			box-shadow: 0 1px 10px rgb(0 0 0 / 7%) !important;
		}
		
		
		li > ul {
			padding-left: 15px !important;
		}

		pre {
			background-color: #f6f8fa !important;
			border-radius: 3px !important;
			/*font-size: 85% !important;*/
			line-height: 1.45 !important;
			overflow: auto !important;
			padding: 16px !important;
			font-family: Monaco, Menlo, Consolas, "Courier New", monospace !important;
			border: 0 !important;
		}
		
		code {
			/*background-color: rgba(27,31,35,.05) !important;*/
			border-radius: 3px !important;
			border: 0 !important;
			/*font-size: 85% !important;*/
			margin: 0 !important;
			padding: 0.2em 0.4em !important;
			font-family: Monaco, Menlo, Consolas, "Courier New", monospace !important;
		}

		table th {
			background-color: #f6f8fa !important;
		}

		
		.math * {
			font-family: Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman', serif !important;
		}

		.katex-display>.katex>.katex-html {
			font-size: 85% !important;
			font-family: Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman', serif !important;
		}

		/*distanzia*/
		h1:not(:first-of-type){
			margin-top: 50px !important;
		}

		/* fa comparire la barra del capitolo */
		h1 {
			border-bottom: 1px solid #e8e8e8fa !important;
			font-size: 2.2em !important;
		}

		/*distanzia*/
		h2 {
			margin-top: 30px !important;
			font-size: 1.6em !important;
		}

		/*distanzia*/
		h3 {
			margin-top: 20px !important;
			font-size: 1.3em !important;
		}

		h4 {
			font-size: 1em !important;
		}

		/* stile box */
		.note, .tip, .caution, .warning, .attention, .error, .danger, .definition {
			border-radius: 5pt;
			padding-left: 10px;
			padding-right: 10px;
			padding-top: 1px;
			padding-bottom: 1px;
			line-height: normal;
			color: #000000ab;
			margin: 6pt 0pt 6pt 0pt;
		}

		.note code, .tip code, .caution code, .warning code, .attention code, .error code, .danger code, .definition code, .danger code {
			background-color: #00000014;
		}

		.note {
			background-color: #88d3f9;
		}

		.tip {
			background-color: #87f0b8;
		}

		.caution, .warning, .attention {
			background-color: #ffe162;
		}

		.error, .danger {
			background-color: #ff7474;
		}

		.definition {
			background-color: #f191ff;
		}

		.table {
			border-top: 1px solid #ddd;
			margin-top: 15px;
		}


	</style>

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />

    <!-- <link rel="stylesheet" type="text/css" href="template.css" /> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/template.css" />

    <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />

    <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
    <!-- <script type='text/javascript' src='menu/js/jquery.cookie.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script> -->

    <!-- <link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" /> -->
  
    <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
        
  
    <!-- <script src="script.js"></script> -->
  
    <!-- <script src="jquery.sticky-kit.js "></script> -->
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.cookie.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.hoverIntent.minified.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/ryangrose/easy-pandoc-templates@948e28e5/css/elegant_bootstrap.css" rel="stylesheet" type="text/css" />
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/script.js"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/jquery.sticky-kit.js"></script>
    <meta name="generator" content="pandoc" />
  <meta name="author" content="Giovanni Enrico Loni" />
  <title>Foundations of CyberSecurity</title>
  <style type="text/css">code{white-space: pre;}</style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  
</head>
<body>

    
    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">Foundations of CyberSecurity</span>
        <ul class="nav pull-right doc-info">
                    <li><p class="navbar-text">Giovanni Enrico
Loni</p></li>
                            </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

        <ul>
        <li><a href="#introduction"
        id="toc-introduction">Introduction</a>
        <ul>
        <li><a href="#outline-of-the-course"
        id="toc-outline-of-the-course">Outline of the course</a></li>
        </ul></li>
        <li><a href="#introduction-to-applied-cryptography"
        id="toc-introduction-to-applied-cryptography">Introduction to
        applied cryptography</a>
        <ul>
        <li><a href="#symmetric-encryption"
        id="toc-symmetric-encryption">Symmetric Encryption</a>
        <ul>
        <li><a href="#the-cipher" id="toc-the-cipher">The
        cipher</a></li>
        <li><a href="#attacks-overview"
        id="toc-attacks-overview">Attacks overview</a></li>
        </ul></li>
        <li><a href="#perfect-cipher" id="toc-perfect-cipher">Perfect
        cipher</a>
        <ul>
        <li><a href="#a-probabilistic-view"
        id="toc-a-probabilistic-view">A probabilistic view</a></li>
        <li><a href="#definition-of-a-perfect-cipher"
        id="toc-definition-of-a-perfect-cipher">Definition of a perfect
        cipher</a></li>
        <li><a href="#shannons-theorem"
        id="toc-shannons-theorem">Shannon’s theorem</a></li>
        <li><a href="#perfect-indistinguishably"
        id="toc-perfect-indistinguishably">Perfect
        indistinguishably</a></li>
        </ul></li>
        <li><a href="#one-time-pad" id="toc-one-time-pad">One-time
        pad</a>
        <ul>
        <li><a href="#proof-for-xor-cipher"
        id="toc-proof-for-xor-cipher">Proof for XOR cipher</a></li>
        <li><a href="#one-time-pad-has-a-perfect-secrecy"
        id="toc-one-time-pad-has-a-perfect-secrecy">One-time pad has a
        perfect secrecy</a></li>
        <li><a href="#one-time-pad-pros-and-cons"
        id="toc-one-time-pad-pros-and-cons">One-time pad: pros and
        cons</a></li>
        <li><a href="#one-time-pad-malleability"
        id="toc-one-time-pad-malleability">One time pad
        malleability</a></li>
        </ul></li>
        <li><a href="#stream-ciphers" id="toc-stream-ciphers">Stream
        ciphers</a>
        <ul>
        <li><a href="#case-study-802.11-wep"
        id="toc-case-study-802.11-wep">Case study: 802.11 WEP</a></li>
        <li><a href="#case-study-linear-feedback-shift-register"
        id="toc-case-study-linear-feedback-shift-register">Case study:
        Linear Feedback Shift Register</a></li>
        <li><a href="#css-content-scrambling-system"
        id="toc-css-content-scrambling-system">CSS: Content Scrambling
        System</a></li>
        </ul></li>
        <li><a href="#random-bit-generator"
        id="toc-random-bit-generator">Random bit generator</a>
        <ul>
        <li><a href="#true-random-bit-generator"
        id="toc-true-random-bit-generator">True random bit
        generator</a></li>
        <li><a href="#pseudo-random-bit-generator"
        id="toc-pseudo-random-bit-generator">Pseudo-random bit
        generator</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#block-ciphers" id="toc-block-ciphers">Block
        ciphers</a>
        <ul>
        <li><a href="#true-random-ciphers"
        id="toc-true-random-ciphers">True random ciphers</a></li>
        <li><a href="#pseudo-random-permutation"
        id="toc-pseudo-random-permutation">Pseudo-random permutation</a>
        <ul>
        <li><a href="#practical-block-ciphers"
        id="toc-practical-block-ciphers">Practical block
        ciphers</a></li>
        </ul></li>
        </ul></li>
        </ul>

        </div>
      </div>
            <div class="span9">

      
      <h1 id="introduction">Introduction</h1>
<h2 id="outline-of-the-course">Outline of the course</h2>
<ol type="1">
<li>Applied cryptography
<ul>
<li>Definition <strong>security</strong></li>
<li>Crypto-primitives: hoe they work and how to use them</li>
<li>Identification and authentication protocols</li>
<li>Case studies</li>
<li>Programming secure applications</li>
</ul></li>
<li>Hands-on labs and challenges</li>
</ol>
<h1 id="introduction-to-applied-cryptography">Introduction to applied
cryptography</h1>
<p>Cryptography, or the art of secret writing, has been around for
thousands of years, and get more and more important in our digital
world, because of the need of secure communication and data protection
in every aspect of our lives, such as online banking, e-commerce,
e-mail, and social media, given the inevitable presence of malicious
actors.</p>
<p>These malicious actors are often referred to as adversaries: they are
<strong>intelligent</strong> users, with an <em>objective</em>, and lot
of <strong>resource</strong> and <strong>abilities</strong>. This leads
to an unfair competition between the adversaries and the defenders, also
called the security engineers: the latter have to protect a system
against all possible attacks, having in mind the usage and performance
of the system, and this will be our role in this course.</p>
<p>Luckily, we don’t have to reinvent the wheel: we can use tools and
techniques that have been developed by cryptographers and security
engineers over the years, and we talk about <strong>applied
cryptography</strong> because of this very fact.</p>
<p>Remember these facts:</p>
<ul>
<li>Cryptography is a <strong>useful</strong> tool, but it is not a
<strong>silver bullet</strong>.</li>
<li>Cryptography is the basis of <strong>security</strong>, but it’s not
the solution to all security problems, and it’s not reliable if not used
properly.</li>
</ul>
<h2 id="symmetric-encryption">Symmetric Encryption</h2>
<p>Let’s give some context to the usage of cryptography in the real
world.</p>
<figure>
<img src="../images/01/scheme1.png"
alt="A simple scheme with our main actors" />
<figcaption aria-hidden="true">A simple scheme with our main
actors</figcaption>
</figure>
<p>In the figure above, we have two main actors: Alice and Bob. They
want to communicate securely, but they are afraid of the presence of an
eavesdropper.</p>
<p>To allow a secure communication, we can use a model, defining the
following elements:</p>
<ul>
<li><strong>Plaintext <em>x</em></strong>: the original message that
Alice wants to send to Bob;</li>
<li><strong>Ciphertext <em>y</em></strong>: the encrypted message that
Alice sends to Bob;</li>
<li><strong>Key <em>k</em></strong>: a shared secret between Alice and
Bob, that is used to encrypt and decrypt the message;</li>
<li><strong>Encryption function <em>E</em></strong>: a function that
takes the plaintext and the key, and returns the ciphertext;</li>
<li><strong>Decryption function <em>D</em></strong>: a function that
takes the ciphertext and the key, and returns the plaintext;</li>
<li><strong>Network</strong>: the insecure communication channel between
Alice and Bob.</li>
</ul>
<p>Note that the encryption and decryption functions are publicly known,
and the only secret is the key.</p>
<h3 id="the-cipher">The cipher</h3>
<p>We define as <strong>cipher</strong> the triple (<em>K</em>,
<em>P</em>, <em>C</em>) of efficient algorithms (<em>Gen</em>,
<em>Enc</em>, <em>Dec</em>) such that:</p>
<ul>
<li><em>Gen</em> is a algorithm <span class="math inline">\(Z^+
\rightarrow K\)</span> that outputs a key;</li>
<li><em>Enc</em> is a algorithm <span class="math inline">\(P \times K
\rightarrow C\)</span> that takes a key and a plaintext, and returns a
ciphertext. An equivalent notations are <span
class="math inline">\(Enc(k, x)\)</span>, <span
class="math inline">\(E(k, x)\)</span>, or <span
class="math inline">\(E_k(x)\)</span>;</li>
<li><em>Dec</em> is a algorithm <span class="math inline">\(C \times K
\rightarrow P\)</span> that takes a key and a ciphertext, and returns a
plaintext. An equivalent notations are <span
class="math inline">\(Dec(k, y)\)</span>, <span
class="math inline">\(D(k, y)\)</span>, or <span
class="math inline">\(D_k(y)\)</span>.</li>
</ul>
<p>Cipher <strong>properties</strong> are also important, and the main
ones are:</p>
<ul>
<li><strong>Correctness</strong>: for every key <span
class="math inline">\(k\)</span> and every plaintext <span
class="math inline">\(p\)</span>, it holds that <span
class="math inline">\(D(k, E(k, x)) = p\)</span>;</li>
<li><strong>Security</strong>: for every key <span
class="math inline">\(k \in K\)</span>, and for every encrypted <span
class="math inline">\(c \in C\)</span>, it’s computationally infeasible
to find both a plaintext <span class="math inline">\(p\)</span> such
that <span class="math inline">\(E(k, p) = c\)</span>, without knowing
<span class="math inline">\(k\)</span>, and the key <span
class="math inline">\(k\)</span> itself.</li>
</ul>
<h4 id="example-mono-alphabetic-substitution">Example: mono-alphabetic
substitution</h4>
<p>A simple example of a cipher is the <strong>mono-alphabetic
substitution</strong>, where each letter of the alphabet is replaced by
another letter, and the key is the mapping between the original and the
substituted letters. The encryption algorithm is implemented by
substituting each letter of the plaintext with the corresponding letter
of the key, and the decryption algorithm is implemented by substituting
each letter of the ciphertext with the corresponding letter of the
inverse key. To break this cipher, we can think of a brute-force attack,
where we try all the possible keys, but this is not feasible because of
the large number of possible keys, which is <span
class="math inline">\(26! \approx 4 \times 10^[26]\)</span>. However,
despite the large number of possible keys, the mono-alphabetic
substitution is not secure, because of the frequency analysis attack,
which is based on the fact that some letters are more frequent than
others in a language, and this can be used to guess the key. From this
example, we can see that the security of a cipher is not only based on
the number of possible keys, but also on the structure of the cipher,
and the security of the key: good ciphers sould hide statistical
properties of the plaintext, and their security mustn’t rely on the
dimensions of the key space.</p>
<h3 id="attacks-overview">Attacks overview</h3>
<p>When we talk about the attack complexity, we refer to the number of
operations that an adversary has to perform to break a cipher, and we
can distinguish between three main types of attacks:</p>
<ul>
<li><strong>Ciphertext-only attack</strong>: the adversary has access to
a set of ciphertexts, and he has to find the plaintexts. This is the
weakest type of attack, and it’s often based on the frequency analysis,
or on the knowledge of the structure of the plaintext;</li>
<li><strong>Known-plaintext attack</strong>: the adversary has access to
a set of plaintext-ciphertext pairs, and he has to find the key. This is
a stronger type of attack, and it’s often based on the knowledge of the
structure of the cipher;</li>
<li><strong>Chosen-plaintext attack</strong>: the adversary has access
to a set of plaintexts, and he has to find the key. This is the
strongest type of attack, and it’s often based on the knowledge of the
structure of the cipher, and on the ability to choose the plaintexts. We
can easily see that if a cipher is secure against chosen-plaintext
attacks, then it’s also secure against known-plaintext attacks and
ciphertext-only attacks.</li>
</ul>
<h4 id="kerckhoffs-principle">Kerckhoffs’ principle</h4>
<p>The security of a cipher must rely only on the secrecy of the key,
and not on the secrecy of the algorithm. This principle was formulated
by Auguste Kerckhoffs in the 19th century, and it’s still valid today,
because it allows the public scrutiny of the algorithms, and it allows
the development of secure ciphers, even if the adversary knows the
algorithm. This because is <strong>easier</strong> to keep a small key
secret, than a large algorithm secret: in case of a leak, changing the
key is easier (and cheaper) than changing the algorithm.</p>
<h4 id="security-trough-obscurity">Security trough obscurity</h4>
<p>The opposite of Kerckhoffs’ principle is the <strong>security trough
obscurity</strong>, which is the reliance on the secrecy of the
algorithm, and it’s a bad practice, because it’s not reliable, and it’s
not a good security measure. This is because the adversary can
reverse-engineer the algorithm, and find the key, and because the
algorithm can be leaked, and the security of the system is compromised.
This has been proved over the year: GSM/A1 were disclosed by mistake,
Enigma was broken by intelligence, and the DVD encryption was broken by
reverse-engineering.</p>
<h2 id="perfect-cipher">Perfect cipher</h2>
<p>In the hypothesis such that attacker isn’t able to recover both some
plaintext and the key, a powerful intuition is, regardless of any <em>a
priori</em> knowledge, the ciphertext shouldn’t reveal any information
about the plaintext.</p>
<h3 id="a-probabilistic-view">A probabilistic view</h3>
<p>Let a message <span class="math inline">\(M\)</span> be a random
variable, with a probability distribution <span
class="math inline">\(P_M\)</span> such that <span
class="math inline">\(P[M = &quot;attack today&quot;] = 0.7\)</span> and
$P[M = <span class="math inline">\(&quot;don&#39;t
attack&quot;\)</span>] = 0.3$ knew <em>a priori</em> by the attacker,
and let <em>Gen()</em> a probability distribution over the keys such
that <span class="math inline">\(P[K = &quot;key1&quot;] = P[k
\leftarrow\)</span> Gen()<span class="math inline">\(]\)</span>, with
<span class="math inline">\(M\)</span> and <span
class="math inline">\(K\)</span> independent. To generate the
ciphertext, we can use the following algorithm:</p>
<ol type="1">
<li>choose a message <span class="math inline">\(m\)</span> according to
<span class="math inline">\(P[M]\)</span>;</li>
<li>generate the key <span class="math inline">\(k\)</span> according to
<span class="math inline">\(P[K]\)</span>;</li>
<li>compute the ciphertext <span class="math inline">\(c = E(k,
m)\)</span>.</li>
</ol>
<h3 id="definition-of-a-perfect-cipher">Definition of a perfect
cipher</h3>
<p>It’s clear that the ciphertext <span class="math inline">\(c\)</span>
is a random variable <span class="math inline">\(C\)</span>, defined by
the encryption function <span class="math inline">\(E\)</span>, so we
can formalize the concept of <em>information about plaintext</em> in
terms of probability distributions. A cipher is said to be
<strong>perfect</strong> if the ciphertext <span
class="math inline">\(C\)</span> is independent of the plaintext <span
class="math inline">\(M\)</span>: <span class="math inline">\(P[M = m |
C = c] = P[M = m]\forall m, c\)</span>. This means that the attacker
can’t learn anything about the plaintext by observing the ciphertext. If
a cipher is perfect, it’s said that it’s <strong>perfectly
secure</strong>, and the necessary conditions for a cipher to be
perfectly secure are that the key must be chosen uniformly at random,
and that the key space must be at least as large as the message space,
as stated by Shannon’s theorem.</p>
<h3 id="shannons-theorem">Shannon’s theorem</h3>
<p>In a perfect cipher, the key space must be at least as large as the
message space. Speaking on mathematical terms, <span
class="math inline">\(|K| \geq |M|\)</span>. We can prove this by
contradiction:</p>
<ol type="1">
<li>suppose that <span class="math inline">\(|K| &lt; |M|\)</span>,
which is the contradiction;</li>
<li>from the previous point, it must be true that <span
class="math inline">\(|C| \geq |M|\)</span>, because the cipher must be
invertible;</li>
<li>combining the two previous points, we have that <span
class="math inline">\(|C| &gt; |K|\)</span>;</li>
<li>now select <span class="math inline">\(m \in M\)</span> such that
<span class="math inline">\(P[M = m] &gt; 0\)</span>, and <span
class="math inline">\(c \in C\)</span> such that <span
class="math inline">\(E(k_i, m) = c \forall k_i in K\)</span>;</li>
<li>because of point 5, must exists al least one <span
class="math inline">\(c\)</span> such that <span class="math inline">\(c
\not ={c_i}\)</span>;</li>
<li>therefore, <span class="math inline">\(P[C = c | M = m] =
0\)</span>, that is a contradiction because the cipher is perfect, so
holds that <span class="math inline">\(P[M = m | C = c] = P[M = m] &gt;
0\)</span>.</li>
</ol>
<h3 id="perfect-indistinguishably">Perfect indistinguishably</h3>
<p>An encryption scheme <span class="math inline">\(\prod =
(G,E,D)\)</span> over <span class="math inline">\((K,M,C)\)</span> is
said to be <strong>perfectly indistinguishable</strong> if:</p>
<ul>
<li><span class="math inline">\(\forall m_1 \text{, } m_2 \in M \text{,
} |m_1| = |m_2|\)</span>;</li>
<li><span class="math inline">\(k \leftarrow\)</span> Gen() is chosen
uniformly at random;</li>
<li><span class="math inline">\(\forall c \in C\)</span>, <span
class="math inline">\(P[E(k, m_1) = c] = P[E(k, m_2) = c]\)</span>.</li>
</ul>
<p>This means that the attacker can’t distinguish between two plaintexts
by observing the ciphertexts: it’s also true that <span
class="math inline">\(\prod\)</span> is perfectly indistinguishable if
and only if it’s perfectly secure.</p>
<h2 id="one-time-pad">One-time pad</h2>
<p>The one-time pad is a perfectly secure cipher, and it’s based on the
following assumptions:</p>
<ul>
<li>let <span class="math inline">\(x\)</span> be a t-bit message,
i.e. <span class="math inline">\(x \in \{0,1\}^t\)</span>;</li>
<li>let <span class="math inline">\(k\)</span> be a t-bit key,
i.e. <span class="math inline">\(k \in \{0,1\}^t\)</span>, where each
bit is chosen uniformly at random;</li>
</ul>
<p>The encryption function <span class="math inline">\(E(k, x)\)</span>
is defined as the bitwise XOR between the message and the key, and the
decryption function <span class="math inline">\(D(k, y)\)</span> is
defined as the bitwise XOR between the ciphertext and the key.</p>
<h3 id="proof-for-xor-cipher">Proof for XOR cipher</h3>
<p>Let <span class="math inline">\(X\)</span> a random variable over
<span class="math inline">\(\{0,1\}^t\)</span>, and <span
class="math inline">\(K\)</span> a random variable over <span
class="math inline">\(\{0,1\}^t\)</span>, with <span
class="math inline">\(X\)</span> and <span
class="math inline">\(K\)</span> independent. Then, define <span
class="math inline">\(Y = X \oplus K\)</span>, where <span
class="math inline">\(\oplus\)</span> is the bitwise XOR. We want to
prove that <span class="math inline">\(Y\)</span> is uniformly
distributed over <span class="math inline">\(\{0,1\}^t\)</span>. The
proof, for <span class="math inline">\(t = 1\)</span>, is the
following:</p>
<ul>
<li><span class="math inline">\(P[X = 0] = X_0, P[X = 1] = X_1\)</span>,
such that <span class="math inline">\(X_0 + X_1 = 1\)</span>;</li>
<li><span class="math inline">\(P[K = 0] = K_0, P[K = 1] = K_1\)</span>,
such that <span class="math inline">\(K_0 + K_1 = 1\)</span>;</li>
<li><span class="math inline">\(P[Y = 0] = P[X = 0, K = 0] + P[X = 1, K
= 1] =\\= P[X = 0]P[K = 0] + P[X = 1]P[K = 1] =\\= X_0K_0 +
X_1K_1\)</span> = <span class="math inline">\(X_0\cdot 0.5 + X_1\cdot
0.5 =\\= 0.5 \cdot (X_0 + X_1) = 0.5\)</span>.</li>
</ul>
<h3 id="one-time-pad-has-a-perfect-secrecy">One-time pad has a perfect
secrecy</h3>
<p>The proof for the one-time pad is the following:</p>
<ol type="1">
<li>from <strong>Bayes’ theorem</strong>, we have that <span
class="math inline">\(P[M = m | C = c] = \frac{P[C = c | M = m]P[M =
m]}{P[C = c]}\)</span>;</li>
<li>from <strong>Total probability theorem</strong>, we have that <span
class="math inline">\(P[C = c] = \\ \sum_{i}^{|M|} P[C = c | M = m_i]P[M
= m_i] = \sum_{i}^{|M|} P[K = c \oplus m_i]P[M = m_i] =\\=
\sum_{i}^{|M|} \frac{1}{2^t}P[M = m_i] = \frac{1}{2^t}\)</span>;</li>
<li>substituting the previous point in the first one, we have that <span
class="math inline">\(P[M = m | C = c] = \\ P[K = c \oplus m] \frac{P[M
= m]}{2^t} = 2^{-t} \frac{P[M = m]}{2^t} = P[M = m]\)</span>.</li>
</ol>
<h3 id="one-time-pad-pros-and-cons">One-time pad: pros and cons</h3>
<p>The one-time pad has some pros:</p>
<ul>
<li>it’s perfectly secure;</li>
<li>it’s simple and efficient;</li>
<li>only one key maps a message <span class="math inline">\(m\)</span>
to a ciphertext <span class="math inline">\(c\)</span>.</li>
</ul>
<p>On the other hand, it has some cons:</p>
<ul>
<li>the key must be as long as the message, so it’s almost impossible to
use it in practice;</li>
<li>keys must be used only once, so they must be shared in advance, and
this is not always possible;</li>
<li>a known-plaintext attack is possible, because the key can be
recovered by XORing the plaintext and the ciphertext.</li>
</ul>
<h3 id="one-time-pad-malleability">One time pad malleability</h3>
<p>A crypto scheme is said to be <strong>malleable</strong> if it’s
possible to modify the ciphertext in such a way that the resulting
plaintext is related to the original plaintext. The one-time pad is
malleable, because if we XOR the ciphertext with a message, we obtain a
new ciphertext that decrypts to a message related to the original
message. A pratical example is the following:</p>
<ul>
<li>suppose that Alice sends a message <span class="math inline">\(c = p
\oplus k\)</span> to Bob, and Eve intercepts the message;</li>
<li>Eve can modify the message by XORing it with another message <span
class="math inline">\(m\)</span>, and send the new message <span
class="math inline">\(c&#39; = c \oplus r\)</span> to Bob, where r is a
<em>perturbation</em>;</li>
<li>Bob now receives the message <span
class="math inline">\(c&#39;\)</span>, and decrypts it to obtain \ <span
class="math inline">\(p&#39; = c&#39; \oplus k = c \oplus r \oplus k = p
\oplus k \oplus r \oplus k = p \oplus r\)</span>.</li>
</ul>
<p>The perturbation goes unnoticed, and can have a significant impact on
the plaintext.</p>
<h2 id="stream-ciphers">Stream ciphers</h2>
<p>The one-time pad is a stream cipher, and it’s based on the concept of
a <strong>keystream</strong>: a sequence of bits that is used to encrypt
the message. The keystream is generated by a <strong>keystream
generator</strong>, which is a function that takes a key and a nonce,
and returns the keystream. The keystream is then XORed with the message
to obtain the ciphertext, and the same keystream is then XORed with the
ciphertext to obtain the message. The keystream generator must be a
<strong>pseudo-random generator</strong>, which is a function that takes
a seed and returns a sequence of bits that is indistinguishable from a
truly random sequence of bits. The keystream generator must also be
<strong>deterministic</strong>, which means that the same seed must
always produce the same sequence of bits.</p>
<p>When we refer to a <strong>pseudo-random generator</strong>, we
mean:</p>
<blockquote>
<p>a deterministic algorithm that, given a truly random binary sequence
of length <span class="math inline">\(k\)</span>, called the
<strong>seed</strong>, produces a binary sequence of length <span
class="math inline">\(n\)</span>, called the <strong>output</strong>,
such that the output is indistinguishable from a truly random sequence
of length <span class="math inline">\(n\)</span>.</p>
</blockquote>
<p>If a pseudo-random generator has these two main properties:</p>
<ul>
<li>it’s <strong>computationally secure</strong>, which means that it
must be computationally infeasible to distinguish the output from a
truly random sequence;</li>
<li>it’s <strong>unpredictable</strong>.</li>
</ul>
<p>then is called <strong>cryptographically secure pseudo-random
generator</strong>. Formally, we can say that given a sequence of bit
<span class="math inline">\(s_i\)</span>, <span
class="math inline">\(s_{i+1}\)</span>, <span
class="math inline">\(s_{i+2}\)</span>, …, <span
class="math inline">\(s_{i+n-1}\)</span>, it’s computationally
infeasible to predict <span class="math inline">\(s_{i+n+1}\)</span> or,
in other words, doesn’t exist an algorithm that can predict the next bit
of the sequence with a probability greater than <span
class="math inline">\(0.5\)</span>.</p>
<h3 id="case-study-802.11-wep">Case study: 802.11 WEP</h3>
<p>The Wired Equivalent Privacy (WEP) is a security protocol for
wireless networks, and it’s based on the RC4 stream cipher. Its
structure is the following:</p>
<figure>
<img src="../images/01/802.11.png" alt="RC4 structure" />
<figcaption aria-hidden="true">RC4 structure</figcaption>
</figure>
<p>The key length is fixed to 104 bits, and the IV length is fixed to 24
bits; it can be settled with a counter, or with a random number. The IV
is concatenated with the key, and the result is used as the seed for the
keystream generator. The keystream is then XORed with the message to
obtain the ciphertext, and the same keystream is then XORed with the
ciphertext to obtain the message. During the years, WEP has been proved
to be insecure, because of the following reasons:</p>
<ul>
<li>the <strong>key is too short</strong> and can be used more than
once, and this can lead to the recovery of the key. In particular, it’s
possible to recover the value of <span class="math inline">\(K\)</span>
in about <span class="math inline">\(40&#39;000\)</span> frames.</li>
<li>the <strong>repetition of the IV</strong> after <span
class="math inline">\(2^{24}\)</span> frames, and this can lead to the
recovery of the keystream.</li>
<li><strong>CRC</strong>, used to check the integrity of the message and
chosen for its execution speed, is not secure and can be easily
forged.</li>
</ul>
<h3 id="case-study-linear-feedback-shift-register">Case study: Linear
Feedback Shift Register</h3>
<p>The LFSR is a pseudo-random generator, and it’s used in many
applications, such as the generation of pseudo-random numbers, the
generation of keystreams, and the generation of test patterns for
digital circuits. First of all, let’s introduce the scheme of a Linear
Feedback Shift Register:</p>
<figure>
<img src="../images/01/LFSR.png" alt="LFSR scheme" />
<figcaption aria-hidden="true">LFSR scheme</figcaption>
</figure>
<p>The crucial parts of the scheme are the <strong>feedback
coefficients</strong>: those are bits that, if settled to 1, enable the
feedback mechanism. The feedback is implemented through a multiplication
between the feedback coefficients and the bits of the register, and the
result is then XORed to obtain the next bit of the register; trying to
compute some steps we can easily get that <span
class="math inline">\(s_{i+m} = \sum {j=0} {m-1} p_js_{i+j} \text{ mod }
2\)</span>, where <span class="math inline">\(p_j\)</span> are the
feedback coefficients.</p>
<h4 id="properties-of-lfsr">Properties of LFSR</h4>
<p>The system is <strong>periodic</strong>, and the period is at most
<span class="math inline">\(2^m - 1\)</span>, where <span
class="math inline">\(m\)</span> is the length of the register, and that
property is called <strong>maximum-length LSFR</strong>. <span
class="math inline">\(m\)</span> is also the <strong>degree</strong> of
the LSFR, and we call <strong>seed</strong> the initial state of the
register, that can assume any value except the all-zero value.</p>
<p>This generator has good statistical properties, but on the other
hand, it’s not secure as a result of the following observation: it’s
<strong>linear</strong> and <strong>periodic</strong> because of its own
construction, means that is <strong>predictable</strong>.</p>
<h4 id="attack-against-lfsr">Attack against LFSR</h4>
<p>It’s possible to perform a Known-Plaintext Attack against the
LFSR:</p>
<ol type="1">
<li>given <span class="math inline">\(2m\)</span> pairs <span
class="math inline">\((p, c)\)</span>, where <span
class="math inline">\(p\)</span> is the plaintext and <span
class="math inline">\(c\)</span> is the ciphertext, the adversary can
determines the prefix of the sequence <span
class="math inline">\(s_i\)</span>;</li>
<li>then, the adversary can determines the feedback coefficients,
resolving a system of <span class="math inline">\(m\)</span> equations
with <span class="math inline">\(m\)</span> unknowns;</li>
<li>finally, the adversary can build the entire LSFR and produces the
entire sequence.</li>
</ol>
<h4 id="how-to-use-lfsr-correctly">How to use LFSR correctly</h4>
<p>A good strategy to use LSFR is to use a non-linear combination of
several LSFRs, such as an AND operation between the outputs of two
LSFRs.</p>
<h3 id="css-content-scrambling-system">CSS: Content Scrambling
System</h3>
<p>The Content Scrambling System is a cryptographic system used to
protect digital video discs: it’s a pseudo-random generator that use
this structure:</p>
<figure>
<img src="../images/01/CSS.png" alt="CSS structure" />
<figcaption aria-hidden="true">CSS structure</figcaption>
</figure>
<p>The output is a keystream, combined with the plaintext with an OR
operation, and it takes as input 5 bytes from two different LSFR. Each
round is composed by 8 clock cycles, in which each LFSR produces 8 bit,
modded by 256.</p>
<h4 id="attack-against-css">Attack against CSS</h4>
<p>This generator is breakable in <span
class="math inline">\(2^{17}\)</span> steps with a Known-Plaintext
Attack: this is possible knowing the format of the media content that
has been encrypted, which has an known initial sequence. In this way, a
prefix of the keystream can be computed; let’s see how.</p>
<p>For all possible setting of an LFSR-17, we have to:</p>
<ol type="1">
<li>run the LFSR-17 to get 20 bytes in output;</li>
<li>subtract LFSR-17<span class="math inline">\(_{1-20}\)</span> from
the keystream<span class="math inline">\(_{1-20}\)</span>, to obtain a
possible output for LFSR-25<span class="math inline">\(_{1-20}\)</span>;
<ul>
<li>if it’s consistent with the known plaintext, we have found the
initial setting for both LFSR-17 and LFSR-25, and the keystream can be
computed.</li>
<li>otherwise, we have to try with another setting.</li>
</ul></li>
</ol>
<p>Using the initial state, we can compute the entire keystream in at
most <span class="math inline">\(2^{17}\)</span> steps, which is
dramatically lower than the <span class="math inline">\(2^{40}\)</span>
steps that would be required to break the system with a brute-force
attack.</p>
<h2 id="random-bit-generator">Random bit generator</h2>
<p>By definition: &gt; a <strong>random bit generator</strong> is a
device/algorithm that <em>outputs a sequence of statistically
independent and unbiased bits</em>.</p>
<p>With <strong>statistically independent</strong> we mean that the
probability of a bit doesn’t depend on the previous bits, and with
<strong>unbiased</strong> we mean that the probability of a bit is <span
class="math inline">\(0.5\)</span>. The main problem is that it’s
impossible to build a random bit generator, because it’s impossible to
build a device/algorithm that is statistically independent and unbiased.
However, we can build a <strong>pseudo-random bit generator</strong>,
which is a device/algorithm that <em>outputs a sequence of bits that is
indistinguishable from a truly random sequence of bits</em>. These
generator can be used to generate <strong>uniformly distributed</strong>
numbers, composed by bits: given an interval <span
class="math inline">\([0, n]\)</span>, we can generate a bit sequence of
length <span class="math inline">\(\lfloor \log_2(n) \rfloor+
1\)</span>, and convert it to an integer.</p>
<p>There are three classes of RGB:</p>
<ul>
<li><strong>true random bit generator</strong>, (TRBG);</li>
<li><strong>pseudo-random bit generator</strong>, (PRBG);</li>
<li><strong>cryptographically secure pseudo-random bit
generator</strong>, (CSPRBG).</li>
</ul>
<h3 id="true-random-bit-generator">True random bit generator</h3>
<p>This category of generators is based on physical processes, such as
radioactive decay, thermal noise, and chaotic systems, such that the
probability to reproduce the same sequence is negligible; they can be
<strong>hardware</strong> or <strong>software</strong> based.</p>
<h4 id="hardware-trbg">Hardware TRBG</h4>
<p>They are based on physical processes, but it’s possible that they can
be influenced by external factors, or malfunctions: for this reason it’s
important to periodically test these generators, to check they’re not
biased, or having non correlated bits. De-skewing is a common technique
to reduce the bias of the output: a common practice is to pass the
sequence through a cryptographic hash function, to reduce the bias.</p>
<p>Another technique is to <strong>group</strong> bits into pairs: given
<span class="math inline">\(p\)</span> the probability of a bit to be
<span class="math inline">\(1\)</span>, and <span
class="math inline">\(1-p\)</span> the probability of a bit to be <span
class="math inline">\(0\)</span>, we can group bits into pairs, and then
apply the following operation:</p>
<ul>
<li>if the pair is <span class="math inline">\(00\)</span> or <span
class="math inline">\(11\)</span>, discard it;</li>
<li>if the pair is <span class="math inline">\(01\)</span>, output <span
class="math inline">\(0\)</span>, with probability <span
class="math inline">\(P[1] = p(1-p)\)</span>;</li>
<li>if the pair is <span class="math inline">\(10\)</span>, output <span
class="math inline">\(1\)</span>, with probability <span
class="math inline">\(P[0] = p(1-p)\)</span>.</li>
</ul>
<p>This operation ensures both that the output is unbiased, and that the
bits are independent, as we can see from the computed probabilities.</p>
<h4 id="software-trbg">Software TRBG</h4>
<p>An example of a software TRBG is the <strong>/dev/random</strong>
device in Unix-like systems, which is based on an <strong>entropy
pool</strong>, which contains a certain number of sources of randomness,
such as keyboard and mouse events, and network traffic. The entropy pool
is then used to generate random numbers, and it’s periodically
replenished with new sources of randomness. The
<strong>/dev/urandom</strong> device is similar to the
<strong>/dev/random</strong> device, but it doesn’t block when the
entropy pool is empty, and it uses a pseudo-random generator to generate
random numbers.</p>
<p>Having multiple sources of randomness is important, because we’re
able to reduce the risk of observation and/or manipulation of the
sources by an adversary.</p>
<h3 id="pseudo-random-bit-generator">Pseudo-random bit generator</h3>
<p>We can give a precise definition of a PRBG:</p>
<blockquote>
<p>a <strong>pseudo-random bit generator</strong> is a deterministic
algorithm that, given a seed of length <span
class="math inline">\(k\)</span>, outputs a sequence of bits of length
<span class="math inline">\(l\)</span>, with <span
class="math inline">\(l \gg k\)</span> that is indistinguishable from a
truly random sequence of bits.</p>
</blockquote>
<p>From the <strong>security</strong> point of view, we can say that a
<em>small</em> seed is expanded into a <em>large(r)</em> pesudo-random
sequence, such that an adversary can’t distinguish the output from a
truly random sequence, and can’t predict the next bit of the sequence
with a probability greater than <span
class="math inline">\(0.5\)</span>; furthermore, the seed must be
sufficiently large, such that it’s infeasible to search over the entire
seed space.</p>
<p>To measure the properties of a PRBG, we can use the
<strong>statistical tests</strong>, such as the <strong>frequency
test</strong>; in general it’s also true that <em>the more the random
string is compressible, the more it’s predictable</em>.</p>
<h4 id="linear-congruential-generator">Linear Congruential
Generator</h4>
<p>The Linear Congruential Generator is a simple PRBG, where <span
class="math inline">\(s_0\)</span> is the <strong>seed</strong>, <span
class="math inline">\(s_{i+1} = (a \cdot s_i + b) \mod m\)</span>, where
<span class="math inline">\(a\)</span>, <span
class="math inline">\(b\)</span>, and <span
class="math inline">\(m\)</span> are constants, and <span
class="math inline">\(s_i\)</span> is the <span
class="math inline">\(i\)</span>-th bit of the sequence.</p>
<p>An unfortunate property of the LCG is that the output is
<strong>predictable</strong>,: knowing a prefix <span
class="math inline">\(s_r\)</span>, <span
class="math inline">\(s_{r+1}\)</span>, <span
class="math inline">\(s_{r+2}\)</span>, it’s possible to easy define a
linear system of two equations with two unknowns, and solve it to obtain
the next bit of the sequence. This is a consequence of the fact that the
LCG is <strong>linear</strong>, and this is a common problem of many
PRBGs, and for this very reason, it’s not suitable for cryptographic
applications.</p>
<h1 id="block-ciphers">Block ciphers</h1>
<p>BLock ciphers are the most used type of encryption. The intuition is
simple: we take the entire block of data, and we split it into smaller
blocks with fixed length, and we encrypt each block separately. The
length is fixed by the chosen algorithm, like the encryption and
decryption functions. In general, we can say that:</p>
<ul>
<li><span class="math inline">\(E_k: \{0,1\}^n \rightarrow
\{0,1\}^n\)</span>, and outputs, in fact, a keyed permutation of the
input. It should be <strong>efficient</strong>,
<strong>bijective</strong> and <strong>invertible</strong>.</li>
<li><span class="math inline">\(D_k: \{0,1\}^n \rightarrow
\{0,1\}^n\)</span>.</li>
</ul>
<h2 id="true-random-ciphers">True random ciphers</h2>
<p>Given the fact that, given <span class="math inline">\(n\)</span> the
length of the block, there are <span class="math inline">\(2^n!\)</span>
possible permutations, a true random cipher should implement all of
them: this is impossible, because the size of the key would be <span
class="math inline">\(\log_2(2n!) \approx (n-1.44)\cdot2^n\)</span>,
which is exponential in <span class="math inline">\(n\)</span>; given
also the fact that the block size cannot be small, in order to
<strong>avoid dictionary attacks</strong> (common values of <span
class="math inline">\(n\)</span> are 64 or 128), we conclude that a true
random cipher is impossible to be implemented.</p>
<h2 id="pseudo-random-permutation">Pseudo-random permutation</h2>
<p>Considering a family of permutation <span class="math inline">\(k \in
K = {0,1}^k\)</span>, <span class="math inline">\(E_k : {0,1}^n
\rightarrow {0,1}^n\)</span> is a pseudo-random permutation if it’s
indistinguishable from a true random permutation, given a random key
<span class="math inline">\(k\)</span>. The number of possible
pseudo-random permutations is <span
class="math inline">\(2^{k}\)</span>, and it’s the practical instance of
a true random permutation.</p>
<h3 id="practical-block-ciphers">Practical block ciphers</h3>
<p>In real life applications, we intend Indistinguishability as the
capacity of the encryption function to choose a key in a way that
appears to be random to an adversary, that is able to perform a
<strong>exaustive search</strong> on the key space.</p>
<figure>
<img src="../images/02/indisti.png" width="500"
alt="Indistinguishability" />
<figcaption aria-hidden="true">Indistinguishability</figcaption>
</figure>
<p>Let assume that the adversary has access to an encryption oracle, so
they cannot look into the box, but only submit an input and get the
relative output. The box, which is our algorithm that choose the
permutation, is considerate secure if the adversary cannot guess which
permutation has bee used with a probability larger that <span
class="math inline">\(0.5\)</span>. Thus, the output of a block cipher
is a uniform random variable, no efficient analytical attack is
possible.</p>
<h4 id="brute-force-attack---exhaustive-search">Brute force attack -
Exhaustive search</h4>
<p>This is a known-plaintext attack, where the adversary has access to a
set of plaintext-ciphertext pairs. Given one of these pairs, check
whether the plaintext is the correct one, by trying all the possible
keys. The complexity of this attack is <span
class="math inline">\(2^k\)</span>, where <span
class="math inline">\(k\)</span> is the length of the key.</p>
<h4 id="false-positive">False positive</h4>
<p>The attack also have to deal with <strong>false positives</strong>:
given a pair of plaintext-ciphertext, such that the ciphertext is the
result of the encryption of the plaintext for a given key, we have to
determines the number of keys that map the plaintext into the
ciphertext. This can be calculated considering that <span
class="math inline">\(P[k] = P[E_{k^*}(\text{plaintext}) =
\text{ciphertext}] = 2^{-n}\)</span>, where <span
class="math inline">\(k^*\)</span> is the correct key, so the number of
keys that map the plaintext into the ciphertext is <span
class="math inline">\(2^k \cdot 2^{-n} = 2^{k-n}\)</span>.</p>
            </div>
    </div>
  </div>
  <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>

</body>
</html>
